#include <set>
#include <cmath>
#include <list>
#include "Interfaces.h"
#include "PairCorrelation.h"
#include "StructureFactor.h"
#include "Voronoi.h"
#include "Plots.h"
#include <boost/math/special_functions.hpp>
#include <nlopt.hpp>

void WriteFunction(const std::vector<GeometryVector> & result, std::ostream & ofile)
{
	for (auto iter = result.begin(); iter != result.end(); iter++)
	{
		for (DimensionType d = 0; d < ::MaxDimension; d++)
			ofile << iter->x[d] << " \t";
		ofile << '\n';
		//ofile<<iter->x[0]<<" \t"<<iter->x[1]<<" \t"<<iter->x[2]<<" \t"<<iter->x[3]<<" \n";
	}
}
void WriteFunction(const std::vector<GeometryVector> & result, const std::string & OutFilePrefix)
{
	std::string name = OutFilePrefix+std::string(".txt");
	std::fstream ofile(name.c_str(), std::fstream::out);
	WriteFunction(result, ofile);
}
void ReadFunction(std::vector<GeometryVector> & result, std::istream & ifile, size_t NumColumns)
{
	if(ifile.good()==false)
	{
		std::cerr<<"Error in ReadFunction : input stream is not good!\n";
		return;
	}
	result.clear();
	while(ifile.eof()==false)
	{
		GeometryVector temp(static_cast<DimensionType>(NumColumns));
		for(size_t i=0; i<NumColumns; i++)
			ifile>>temp.x[i];
		if(ifile.eof()==false)
			result.push_back(temp);
	}
}
void ReadFunction(std::vector<GeometryVector> & result, const std::string & InFilePrefix, size_t NumColumns)
{
	std::string name = InFilePrefix+std::string(".txt");
	std::fstream ifile(name.c_str(), std::fstream::in);
	ReadFunction(result, ifile, NumColumns);
}



//const size_t InnerFolderNum=500;
//int PairStatisticsCalculation_TwoLayerFolder(const size_t NumConfig, const char * path, const char * PostName, double g2rmax, double circularKmax, double linearKmax, Configuration (*GetConfigFunction)(std::istream & ifile), const std::string & OutputPrefix, double Rescale=1.0)
//{
//	size_t NumP;
//	std::cin>>NumP;
//	std::vector<GeometryVector> result;
//	::IsotropicTwoPairCorrelation([&NumP, &path, &PostName, &GetConfigFunction, &Rescale](size_t i) ->Configuration
//	{
//		std::stringstream name;
//		name<<path;
//		//name<<i+1;
//		size_t OuterFolder=i/InnerFolderNum+1;
//		size_t InnerFolder=i%InnerFolderNum;
//		name<<OuterFolder<<"/_0_0.02_"<<NumP<<"_500_"<<InnerFolder;
//		name<<PostName;
//		std::string filename;
//		name>>filename;
//		std::fstream ifile(filename.c_str(), std::fstream::in);
//		std::cout<<"g2 read"<<i<<"\n";
//		Configuration result=GetConfigFunction(ifile);
//		result.Rescale(Rescale);
//		return result;
//	}
//	, NumConfig, g2rmax, result, 5000000, 1.0);
//	PlotIsotropicTwoPairCorrelation(result, OutputPrefix, g2rmax);
//	logfile<<"g_2:\n";
//	for(auto iter=result.begin(); iter!=result.end(); iter++)
//		logfile<<iter->x[0]<<" \t"<<iter->x[1]<<" \t"<<iter->x[2]<<" \t"<<iter->x[3]<<" \n";
//	{
//		std::string name(OutputPrefix);
//		name+=std::string("_PairCorrelation.txt");
//		std::fstream ofile(name.c_str(), std::fstream::out);
//		for(auto iter=result.begin(); iter!=result.end(); iter++)
//			ofile<<iter->x[0]<<" \t"<<iter->x[1]<<" \t"<<iter->x[2]<<" \t"<<iter->x[3]<<" \n";
//	}
//
//
//	result.clear();
//	::IsotropicStructureFactor([&NumP, &path, &PostName, &GetConfigFunction, &Rescale](size_t i) ->Configuration
//	{
//		std::stringstream name;
//		name<<path;
//		//name<<i+1;
//		size_t OuterFolder=i/InnerFolderNum+1;
//		size_t InnerFolder=i%InnerFolderNum;
//		name<<OuterFolder<<"/_0_0.02_"<<NumP<<"_500_"<<InnerFolder;
//		name<<PostName;
//		std::string filename;
//		name>>filename;
//		std::fstream ifile(filename.c_str(), std::fstream::in);
//		std::cout<<"sk read"<<i<<"\n";
//		Configuration result=GetConfigFunction(ifile);
//		result.Rescale(Rescale);
//		return result;
//	}
//	, NumConfig, circularKmax, linearKmax, result);
//	PlotIsotropicStructureFactor(result, OutputPrefix, linearKmax);
//	logfile<<"Sk:\n";
//	for(auto iter=result.begin(); iter!=result.end(); iter++)
//		logfile<<iter->x[0]<<" \t"<<iter->x[1]<<" \t"<<iter->x[2]<<" \n";
//	{
//		std::string name(OutputPrefix);
//		name+=std::string("_StructureFactor.txt");
//		std::fstream ofile(name.c_str(), std::fstream::out);
//		for(auto iter=result.begin(); iter!=result.end(); iter++)
//			ofile<<iter->x[0]<<" \t"<<iter->x[1]<<" \t"<<iter->x[2]<<" \n";
//	}
//
//	return 0;
//}

int QuantizerError(const size_t NumConfig, const char * path, const char * PostName, double g2rmax, double circularKmax, double linearKmax, Configuration (*GetConfigFunction)(std::istream & ifile), const std::string & OutputPrefix, double Rescale=1.0)
{
	const double SamplePerConfig=1000;
	std::string name(OutputPrefix);
	name+="QuantizerError.txt";
	std::fstream ofile(name.c_str(), std::fstream::out);
#pragma omp parallel for
	for(int i=0; i<NumConfig; i++)
	{
		RandomGenerator gen(i*500);
		std::stringstream name;
		name<<path;
		name<<i+1;
		//size_t OuterFolder=i/InnerFolderNum+1;
		//size_t InnerFolder=i%InnerFolderNum+1;
		//name<<OuterFolder<<'/'<<InnerFolder;
		name<<PostName;
		std::string filename;
		name>>filename;

		std::cout<<"Quantizer read"<<i<<"\n";
		std::fstream ifile(filename.c_str(), std::fstream::in);
		Configuration c=GetConfigFunction(ifile);
		c.Rescale(Rescale);
		DimensionType dim=c.GetDimension();

		double Sumx2=0;
		double Sumx22=0;

		double TypicalLength=std::pow(c.PeriodicVolume()/c.NumParticle(), 1.0/c.GetDimension())*1.5;
		for(size_t j=0; j<SamplePerConfig; j++)
		{
			std::vector<double> neighbors;
			double l=TypicalLength;
			GeometryVector startPoint(dim);
			for(DimensionType i=0; i<dim; i++)
				startPoint.x[i]=gen.RandomDouble();

			while(neighbors.size()<2)
			{
				neighbors.clear();
				c.IterateThroughNeighbors(startPoint, l, [&neighbors](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
				{
					neighbors.push_back(shift.Modulus2());
				});
				l*=2;
			}

			std::partial_sort(neighbors.begin(), neighbors.begin()+1, neighbors.end());

			Sumx2 += neighbors[0];
			Sumx22 += neighbors[0]*neighbors[0];
		}
#pragma omp critical
		{
			ofile<<i<<" \t"<<Sumx2/SamplePerConfig/dim*std::pow(c.NumParticle()/c.PeriodicVolume(), (double)(2)/dim)<<'\n';
		}
	}
	return 0;
}
//not so optimized
inline void Ev(Configuration & config)
{
	const double SamplePerConfig=1000;
	DimensionType dim=config.GetDimension();
	double TypicalLength=std::pow(config.PeriodicVolume()/config.NumParticle(), 1.0/dim);
	std::vector<double> lengths;
	RandomGenerator gen;

	for(size_t i=0; i<SamplePerConfig; i++)
	{
		GeometryVector Random(dim);
		for(DimensionType j=0; j<dim; j++)
			Random.x[j]=gen.RandomDouble();

		double Radius=0.5*TypicalLength;
		double NearestNeighborDistance2=2e10;
		while(NearestNeighborDistance2>1e10)
		{
			config.IterateThroughNeighbors(Random, Radius, [&NearestNeighborDistance2]
			(const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
			{
				double dist2=shift.Modulus2();
				if(dist2<NearestNeighborDistance2)
					NearestNeighborDistance2=dist2;
			});
			Radius=Radius*2;
		}
		lengths.push_back(std::sqrt(NearestNeighborDistance2));
	}

	std::sort(lengths.begin(), lengths.end());
	for(size_t i=0; i<lengths.size(); i+=10)
		std::cout<<lengths[i]<<" \t"<<static_cast<double>(lengths.size()-i)/(lengths.end()-lengths.begin())<<'\n';
}

//all configurations must have the same basis vectors
void AngularStructureFactor(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig, double KMax)
{
	std::vector<GeometryVector> ks;
	Configuration c=GetConfigsFunction(0);
	DimensionType dim=c.GetDimension();
	std::vector<GeometryVector> bs;
	for(DimensionType i=0; i<dim; i++)
		bs.push_back(c.GetReciprocalBasisVector(i));
	//for(int ii=-150; ii<151; ii++)
	//	for(int jj=-150; jj<151; jj++)
	//	{
	//		GeometryVector k=(double)(ii)*c.GetReciprocalBasisVector(0)+(double)(jj)*c.GetReciprocalBasisVector(1);
	//		ks.push_back(k);
	//	}
	Configuration reciprocal(dim, &bs[0], std::sqrt(bs[0].Modulus2()));
	reciprocal.Insert("H", GeometryVector(dim) );
	reciprocal.IterateThroughNeighbors(GeometryVector(dim), KMax, [&ks](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t SourceAtom)->void{ks.push_back(shift);} );

	std::vector<double> sums(ks.size(), 0.0);
	for(size_t i=0; i<NumConfig; i++)
	{
		c=GetConfigsFunction(i);
		for(size_t j=0; j<ks.size(); j++)
		{
			double s=StructureFactor(c, ks[j]);
			sums[j]+=s;
		}
	}
	for(size_t j=0; j<ks.size(); j++)
	{
		logfile<<ks[j].x[0]<<" \t"<<ks[j].x[1]<<" \t"<<sums[j]/NumConfig<<'\n';
	}
}

//packing fraction if each of the configurations in a is replaced by a sphere with diameter MinDistance(a)
double PackingFraction(const Configuration & a)
{
	double diameter=MinDistance(a);
	return HyperSphere_Volume(a.GetDimension(), diameter*0.5)*a.NumParticle()/a.PeriodicVolume();
}

//return the minimum radius so that if each particle is replaced with a sphere, they cover the space
double MinimumCoveringRadius(const Configuration & a)
{
	double maxr2=0.0;
	for(int i=0; i<a.NumParticle(); i++)
	{
		std::vector<GeometryVector> vert;
		GetVoronoiCell(a, i, vert);
		for(auto iter=vert.begin(); iter!=vert.end(); iter++)
		{
			GeometryVector dist=*iter-a.GetCartesianCoordinates(i);
			double r2=dist.Modulus2();
			if(maxr2<r2)
				maxr2=r2;
		}
	}
	return std::sqrt(maxr2);
}




//todo : use function Psi6 (defined in PeriodicCellList.cpp)
#include <complex>
typedef std::complex<double> complex;
//g_6=<Psi_6*(r)Psi_6(0)>_r,
//where Psi_6=1/6( \Sum_{six nearest neighbors} exp(6i \theta) ),
//where theta is the angle between the bond and some reference direction
//only works for d=2
void Psi6Correlation(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, std::vector<GeometryVector> & Result, double MaxDistance, double RPrecision)
{
	if(Verbosity>2)
		std::cout<<"Generate Psi6Correlation";
	progress_display pd(NumConfigs);

	std::vector<double> distances;

	DimensionType dim;

	struct BinType
	{
		size_t Count;
		double Sum;
		double Sum2;
		BinType() : Count(0), Sum(0.0), Sum2(0.0) {}
	};
	size_t NumBins=std::ceil(MaxDistance/RPrecision);
	std::vector<BinType> vBins(NumBins, BinType());

	for(size_t j=0; j<NumConfigs; j++)
	{
		pd++;
		Configuration Config = GetConfigsFunction(j);
		if(Config.GetDimension()!=2)
		{
			std::cerr<<"Error in Psi6Correlation() : configuration is not two-dimensional!\n";
			assert(false);
		}
		if(j==0)
			dim=Config.GetDimension();
		size_t NumParticle=Config.NumParticle();
		std::vector<complex> VPsi6(NumParticle, 0.0);

		double TypicalLength=std::pow(Config.PeriodicVolume()/Config.NumParticle(), 1.0/Config.GetDimension())*1.5;
		Config.SetCellSize(TypicalLength*2);

		long end=NumParticle;
#pragma omp parallel 
		{
			Configuration ThreadConfig(Config);
#pragma omp for schedule(dynamic)
			for(long j=0; j<end; j++)
			{
				if(Verbosity>4)
					std::cout<<"Doing Particle"<<j<<'\n';


				VPsi6[j] = Psi6(ThreadConfig, j, 1);
			}
		}

		for(long j=0; j<end; j++)
		{
			auto func=[&] (const GeometryVector &shift, const GeometryVector &LatticeShift, const signed long *PeriodicShift, const size_t SourceAtom) ->void
			{
				size_t index=std::sqrt(shift.Modulus2())/RPrecision;
				if(index<NumBins)
				{
					double result=(std::conj(VPsi6[j])*VPsi6[SourceAtom]).real();
					vBins[index].Count++;
					vBins[index].Sum+=result;
					vBins[index].Sum2+=result*result;
				}
			};
			GeometryVector Rel=Config.GetRelativeCoordinates(j);
			Config.IterateThroughNeighbors(Rel, MaxDistance, func);
		}
	}
	for(auto iter=vBins.begin(); iter!=vBins.end(); iter++)
	{
		GeometryVector temp(4);
		temp.x[0]=((double)(iter-vBins.begin())+0.5)*RPrecision;
		temp.x[1]=iter->Sum/iter->Count;
		temp.x[2]=RPrecision;
		double c=(double)(iter->Count);
		temp.x[3]=(iter->Sum2/c-iter->Sum*iter->Sum/c/c)/std::sqrt(c);
		if(iter->Count>0)
			Result.push_back(temp);

	}

	if(Verbosity>2)
		std::cout<<"done!\n";
}

double Tau(const std::vector<GeometryVector> & data, DimensionType d)
{
	double sum = 0.0;
	if (data.size() < 2)
	{
		std::cout << "Error in Tau : not enough data!\n";
		return 0.0;
	}
	for (auto iter = data.begin() + 1; iter != data.end(); ++iter)
	{
		double x1 = (iter - 1)->x[0], x2 = iter->x[0];
		if (x2 < x1)
		{
			std::cout << "Error in Tau : x is not monotonic!\n";
			return 0.0;
		}
		double y1 = std::pow((iter - 1)->x[1] - 1, 2.0);
		double y2 = std::pow((iter)->x[1] - 1, 2.0);
		sum += 0.5*(y1 + y2)*(HyperSphere_Volume(d, x2) - HyperSphere_Volume(d, x1));
	}
	return sum;
}
double TauFromG2(const std::vector<GeometryVector> & data, DimensionType d)
{
	return Tau(data, d);
}
double TauFromSk(const std::vector<GeometryVector> & data, DimensionType d, double NumberDensity)
{
	return Tau(data, d) / (std::pow(2 * pi, d)*NumberDensity*NumberDensity);
}
namespace FirstPassageTime
{
	//pre-computed first passage time cumulative distribution function

	//3D
	double aP3[2000] = {
		-0.0000000000000000002683473168795528140603834366118, -0.0000000000000000000095125770443598182610211999588046, 0.0000000000000000000070757029597785987308500299519665, 0.0000000000000000000020960756722093721281241496257053, 0.0000000000000000000030787662399223690058713831518844, 0.00000000000000001168896533660318895215396439724, 0.0000000000000041628314643856591606169842423313, 0.00000000000033822640252182105588248193367429, 0.000000000010270656301373405437870028455299, 0.00000000015670866531017506738442877619114, 0.0000000014502056158312748544146709235754, 0.0000000092270469401656676456430526212307, 0.000000044021660838773793224337841636581, 0.00000016754537198758379920863623364132, 0.00000053231421615359561498549692743799, 0.0000014606420129620470741488641986902, 0.0000035526059695725684562167317261409, 0.0000078153962569617795933447959488209, 0.000015800731061303464498210713782579, 0.000029734390294685954158437774754364, 0.00005262268557521061762358282928295, 0.000088324085976104035253324210239174, 0.00014157903462429852207430626700281, 0.00021799603035661013986226579181309, 0.00032399643824356469431696148789367, 0.000466723754579528763163107202092, 0.00065392505025229125995342775866419, 0.00089381315230317327957438140623869, 0.0011949180264800955292915340780912, 0.0015659350661781909492342783678809, 0.0020155768348610911882629261070355, 0.0025524334665136311280686635615363, 0.0031848455649845851751131304024114, 0.0039207921690589917928709852347835, 0.004767795231878404153820570706855, 0.0057328411322273841889677295876847, 0.0068223189975819492097173421518968, 0.0080419750646043052098274439027577, 0.0093968819122729445060717056076077, 0.01089142115176354860193302005755, 0.0125292780201302809332729576044, 0.014313446277476685803598771151593, 0.016246241827747021696798496206644, 0.018329323552621748585622374521631, 0.020563719950548082604988772798651, 0.022949860296011158511551837081631, 0.025487609167851206849913466433475, 0.028176303332257624591349404756369, 0.031014790100542098789554044965525, 0.034001466410081367395792151860004, 0.037134317996412976642415470703051, 0.040410958133874904017609237240701, 0.043828665520688029300243181369895, 0.047384420971846197349467108704245, 0.05107494265986543467295212612879, 0.054896719709891303724667363088283, 0.058846044012586247129019919911809, 0.062919040166430771958174148313558, 0.067111693501429349552135459682285, 0.071419876169571280240756540263434, 0.075839371314588879922796155208937, 0.080365895355364873472948123734495, 0.08499511843449533199213644078456, 0.089722683096678116154638072020132, 0.094544221271368444996639386689715, 0.0994553696410570112080975066036, 0.10445178348105391328929806401464, 0.10952914905921701779295335812588, 0.1146831946850056563981989564347, 0.11990970049688007771216759462776, 0.12520450707566979894256811963292, 0.13056352296932642554951673617266, 0.13598273121165018232944339826511, 0.14145819491429521512251642041016, 0.14698606200775082448581677601186, 0.15256256920317515054013466658914, 0.15818404524301543976585466130568, 0.16384691350435877315977793990873, 0.16954769401497831638200839964482, 0.17528300493811969415461290596643, 0.18104956357824649263489095624484, 0.18684418695626091056615517766704, 0.19266379199915568132293863178075, 0.19850539538565100813663089060459, 0.20436611308613486789103963294609, 0.21024315963216207395921404103284, 0.21613384714787910704536807724622, 0.22203558417302747601368785775716, 0.227945874304635752260051613212, 0.23386231468213533172659383377078, 0.23978259433842211128631195851499, 0.2457044924373294270163753958634, 0.2516258764160699737949021972011, 0.25754470004943878453958620813669, 0.26345900145093823740430231129885, 0.26936690102448193397685592356765, 0.27526659937894962642194559006407, 0.28115637521659275210213013182087, 0.28703458320512232418622739290424, 0.29289965184224091942529120626324, 0.2987500813204015601782929762151, 0.30458444139868196097047082683811, 0.31040136928784676502596705415827, 0.31619956755392721816288379529387, 0.32197780204497172475547444786873, 0.3277348998450067343049791066103, 0.33346974725869056632710060488553, 0.33918128782963855444810821551874, 0.34486852039494203643265124947348, 0.3505304971779922824082980794621, 0.35616632192134976169950804438267, 0.36177514806106578486326836248392, 0.36735617694356435599588189426295, 0.37290865608592410043928034760599, 0.37843187748016068519835965812707, 0.38392517594189672195282695070547, 0.38938792750361642829821797657334, 0.39481954785253419633026080988884, 0.40021949081295772293184500769865, 0.4055872468728956949268680119001, 0.41092234175454554301743014270006, 0.41622433502819696552307681035504, 0.42149281876900038681905219749195, 0.42672741625597498306838069415907, 0.43192778071256721419141156521993, 0.43709359408801688036190241679867, 0.44222456587874259979339019865568, 0.44732043198892139289209366596843, 0.45238095362940694457445840623256, 0.45740591625410736187409009067359, 0.46239512853292517392082931952202, 0.4673484213603493224517329138021, 0.47226564689878040518862660876559, 0.47714667765566595456085816766576, 0.48199140559352159988152265319205, 0.48679974127191615444129593075227, 0.49157161302050361141707913581614, 0.49630696614219238112991469008786, 0.50100576214555154686728792569996, 0.50566797800556517693584532324452, 0.51029360545185855385260920062885, 0.51488265028353433954810973611631, 0.51943513170977198279470199231163, 0.5239510817153599071530295094743, 0.5284305444503470287820264954806, 0.53287357564301779489667506530611, 0.53728024203541307252860282594671, 0.54165062084063773480701463503078, 0.54598479922121458240847255522358, 0.55028287378776320702930763535628, 0.55454495011730146826411808213503, 0.55877114229048634132820281985643, 0.5629615724471299355861614017159, 0.56711637035934542570362579696399, 0.57123567302169642844465688218918, 0.57531962425774195518384969491695, 0.57936837434238743541979690009445, 0.58338207963947040756250211422686, 0.58736090225402728236256843544003, 0.59130500969870507816315361729402, 0.5952145745737991861296413893308, 0.59908977426041503163023754378415, 0.60293079062626794196671445076071, 0.60673780974365160040855623877082, 0.61051102161912115414424050051618, 0.61425061993445234369967788409577, 0.617956801798452929901432520195, 0.62162976750921720962292539668415, 0.62526972032642853291093103076963, 0.62887686625332846255792846327159, 0.63245141382798455485220608507414, 0.63599357392350169022363713690463, 0.63950355955683444882608712899833, 0.64298158570587021355333186032739, 0.64642786913446449703558539379726, 0.64984262822512143584116905853737, 0.6532260828190234809252919299025, 0.6565784540631250452415828197379, 0.65989996426403525460855839028858, 0.66319083674842499391767994646143, 0.66645129572970315530727771823283, 0.66968156618071638589352760223476, 0.67288187371223570804650936404515, 0.67605244445700215310199763142442, 0.67919350495911201792343052282205, 0.68230528206853053099659082843176, 0.68538800284053060885585276747514, 0.6884418944398610026650956124622, 0.6914671840494554867036350961533, 0.69446409878350183324864863687749, 0.69743286560469615971321581769711, 0.70037371124551483159113801832193, 0.7032868621333424663506632733219, 0.7061725443193007163481961384068, 0.70903098341062842039584158092184, 0.71186240450646941096045586476166, 0.71466703213692975408719160150805, 0.71744509020527148885974780420798, 0.72019680193311502920130305327948, 0.72292238980852729958823421088023, 0.72562207553687740413060905910358, 0.72829607999434618163864020272306, 0.73094462318398038374514800273692, 0.73356792419418643472556070339571, 0.73616620115956279601804515121555, 0.73873967122397387110092744618716, 0.74128855050577215267356598339644, 0.74381305406507893919011275752505, 0.74631339587303743673428930443323, 0.74878978878295541986246243544536, 0.75124244450325785609362719641827, 0.75367157357217300774966929358204, 0.75607738533407851626177065197844, 0.75846008791743685212863180344884, 0.76081988821425228256908543960658, 0.76315699186098417254685783438961, 0.76547160322085399711723345475273, 0.76776392536748590768063663329313, 0.77003416006982306532755855056323, 0.77228250777826423449877655907972, 0.77450916761196732302106386379446, 0.77671433734726866345076702041767, 0.77889821340716885869224276527131, 0.78106099085183796507090295576758, 0.78320286337009466134125868706819, 0.78532402327181585530469183065398, 0.78742466148123491350549323561596, 0.78950496753108836647595900012839, 0.7915651295575725447263674533692, 0.79360533429607314154786998805506, 0.79562576707763218005127799955396, 0.79762661182611828595338281549702, 0.79960805105606753661356732692994, 0.80157026587116347280625058783552, 0.80351343596332612470136107294714, 0.80543773961238111945437432267136, 0.80734335368628110654559251184238, 0.80923045364185286035330639239207, 0.81109921352604449912794595034022, 0.81294980597764829722082403670674, 0.81478240222947556471593721295869, 0.81659717211096102706097210335012, 0.8183942840511750583810093133628, 0.82017390508222300731587546922455, 0.82193620084301170482761605542561, 0.82368133558336406080275314918276, 0.82540947216846344170102712196278, 0.82712077208361027620518337085096, 0.82881539543927406098619031648517, 0.8304935009764246354515349748632, 0.83215524607212726378412934895491, 0.83380078674538670575781847566677, 0.83543027766322607574453986835628, 0.83704387214698688298124233548786, 0.83864172217883721647837777261838, 0.84022397840847558582680481895434, 0.84179079016001845546300477834528, 0.84334230543906001551696757949765, 0.84487867093989321799455305325575, 0.84640003205288157350792793773563, 0.84790653287197165180493756345386, 0.84939831620233665967463161331635, 0.8508755235681418831072393102225, 0.852338295220423177522433497223, 0.85378677014507007108408195544007, 0.85522108607090541220274152767391, 0.85664137947785384387586527164054, 0.85804778560519172509348744982559, 0.85944043845987144368735098654586, 0.86081947082491337624468118197079, 0.86218501426785904954627593489533, 0.8635371991492793449042514728522, 0.86487615463133186223103689013372, 0.86620200868636182511454289378414, 0.8675148881055411620326396694602, 0.86881491850754064252589574168148, 0.87010222434723018105693540179778, 0.87137692892440264579866684045833, 0.87263915439251672507836657096957, 0.87388902176745461101224267798966, 0.87512665093629045833414534024309, 0.876352160666065766878053453554, 0.87756566861256801892955168898445, 0.87876729132910907801779519649782, 0.87995714427530002396521808535576, 0.88113534182581926042579989346891, 0.88230199727917088599109856194396, 0.88345722286643046848333681010806, 0.88460112975997550453376109918189, 0.88573382808219798319933034510032, 0.88685542691419660343013482682809, 0.8879660343044463208827275373358, 0.88906575727744302009201427066024, 0.89015470184232122356889619989742, 0.89123297300144286017754703781259, 0.89230067475895522135213441239174, 0.89335791012931633551814493257365, 0.89440478114578608866116005420105, 0.89544138886888151250239725704866, 0.89646783339479475135534649157785, 0.89748421386377230460513348312152, 0.89849062846845422401955382275173, 0.89948717446217202390992615551487, 0.90047394816720413764758995205756, 0.9014510449829878263390404561318, 0.90241855939428651469560632367839, 0.9033765849793115954231266556663, 0.90432521441779780692004997241027, 0.90526453949903134982036800738932, 0.90619465112982996605867305679957, 0.90711563934247425977151526852456, 0.90802759330258959258174478025805, 0.90893060131697793673595249954054, 0.90982475084139911827140044866752, 0.91071012848830092896607090800399, 0.91158682003449763035853512176755, 0.91245491042879641569457051556322, 0.91331448379957143634334296372129, 0.91416562346228503810255615325258, 0.91500841192695588995170792420938, 0.9158429309055737232849519056273, 0.91666926131946043352673573045283, 0.91748748330657732836869782072717, 0.91829767622877833772680204081682, 0.91909991867900902996267069104795, 0.91989428848845130699958207739461, 0.92068086273361367774618180628831, 0.921459717743367034772346472486, 0.92223092910592588351236699587708, 0.92299457167577499644909809265553, 0.92375071958054148680577527754937, 0.92449944622781231728458847536697, 0.92524082431189727938588148595818, 0.92597492582053749786041462337052, 0.92670182204155953292933739942053, 0.92742158356947517009040621738518, 0.92813428031202700365146740814738, 0.92883998149667993562840254357157, 0.92953875567705872634858799714813, 0.9302306707393317470449938209664, 0.93091579390854109794163537651099, 0.93159419175487926784813542407773, 0.93226593019991252312870677924722, 0.93293107452275122511656228910183, 0.93358968936616728563510759563522, 0.93424183874265898028822986670436, 0.93488758604046334861769124438075, 0.93552699402951641912012194452187, 0.93616012486736150549168387475883, 0.93678704010500582834730479821485, 0.93740780069272572406399277121238, 0.93802246698582070934470611555132, 0.93863109875031667660934096902274, 0.93923375516861850141172759870243, 0.93983049484511234877337796324166, 0.94042137581171797063364331927075, 0.94100645553339129155799410245549, 0.94158579091357758443745489764257, 0.94215943829961554216754051416229, 0.94272745348809255522941292376302, 0.94328989173015150872280515394999, 0.94384680773674941573353305465503, 0.94439825568386820697049724952483, 0.94494428921767799939073721334255, 0.94548496145965316905795917179571, 0.94602032501164155576153871618387, 0.94655043196088712897019824983439, 0.94707533388500644651789210054952, 0.94759508185691923902901641759501, 0.94810972644973345449548384586028, 0.94861931774158509862891745391164, 0.949123905320433207635951242187, 0.9496235382888102909121074910878, 0.95011826526852858182804074388072, 0.9506081344053424352991146993471, 0.95109319337356721119265046040629, 0.95157348938065498284437905273864, 0.95204906917172741003315614880316, 0.95251997903406611570794971724123, 0.952986264801560905579679176461, 0.95344797185911616938882509668934, 0.953905145147015802243835317676, 0.95435782916524698390087782748431, 0.95480606797778315322769375009954, 0.955249905216826514368691030087, 0.9556893840870104103096826496721, 0.9561245473695618986337920946807, 0.95655543742642486326959430083568, 0.95698209620434399496279078674798, 0.95740456523890997205809327243049, 0.95782288565856617196232078620172, 0.95823709818857724237703937418528, 0.95864724315495986004302733122155, 0.9590533604883760033330355686396, 0.95945548972798906356711880041711, 0.95985367002528311840949610203672, 0.96024794014784568914068011713311, 0.96063833848311430198632667659645, 0.96102490304208717202800278044999, 0.96140767146299832652332569894641, 0.96178668101495748272665399124392, 0.96216196860155499352885822423866, 0.96253357076443217242848909525449, 0.96290152368681730750881092498687, 0.96326586319702767222823177073216, 0.9636266247719378389374889447204, 0.96398384354041459911775238926444, 0.96433755428671879239142450040287, 0.96468779145387434439373784834994, 0.9650345891470048116100387479942, 0.96537798113663772928257561691357, 0.9657180008619770564733805877928, 0.96605468143414401033784712378003, 0.96638805563938657961853136095787, 0.96671815594225800531174494670105, 0.96704501448876451439220246654935, 0.96736866310948259040450513436532, 0.96768913332264606264583661241864, 0.96800645633720329357314085695003, 0.96832066305584474197128303520484, 0.96863178407800117731740764985788, 0.96893984970281281867188903546724, 0.96924488993206966931884811010347, 0.969546934473123316270174981615, 0.96984601274177046163726623822926, 0.97014215386510845076487888281102, 0.97043538668436305991275809962869, 0.97072573975768880416346335816725, 0.97101324136294202412997191746336, 0.97129791950042700793490355247723, 0.97157980189561540283507331772055, 0.97185891600183916877135102972824, 0.97213528900295732403490709674737, 0.9724089478159967311575789614342, 0.97267991909376716905665312934179, 0.97294822922745093539346477033978, 0.9732139043491672210412639398066, 0.9734769703345114965013354737599, 0.97373745280507014805759039911384, 0.97399537713091059941950811207726, 0.9742507684330471525714403190052, 0.97450365158588277952348868355035, 0.97475405121962709464564342252323, 0.97500199172269073526299858918067, 0.97524749724405637619591940940708, 0.97549059169562660194528091069969, 0.97573129875454885824967758495864, 0.97596964186551770277891690676564, 0.97620564424305457277654561836142, 0.97643932887376528552372928746418, 0.9766707185185754855677443549812, 0.97689983571494425074081149831517, 0.97712670277905606708924448781546, 0.97735134180799138093894951364404, 0.9775737746818759344414757211286, 0.97779402306600908907506359914432, 0.97801210841297133971777493811053, 0.97822805196471122006474351991554, 0.9784418747546117983291176018432, 0.97865359760953696034634714058857, 0.9788632411518576753942957853423, 0.97907082580145843824719851783033, 0.97927637177772407919989759643387, 0.97947989910150713203008044289055, 0.97968142759707594811046457878885, 0.9798809768940437431401275911494, 0.98007856642927876123438000941562, 0.98027421544879573939595255764124, 0.98046794300962885368658324062916, 0.9806597679816863267276352988223, 0.9808497090495868744809143414934, 0.98103778471447816859662347796701, 0.98122401329583748896417071038377, 0.98140841293325473946349362809035, 0.98159100158819799828966277460671, 0.98177179704576177261157503738315, 0.98195081691639812572683658834373, 0.98212807863763084328917838375015, 0.98230359947575280361199730041036, 0.98247739652750671549196859464833, 0.98264948672174938544989229273025, 0.9828198868210996747521000746694, 0.98298861342357030505488170420173, 0.98315568296418367000622969716463, 0.98332111171657180864397601037083, 0.98348491579456069494684864735759, 0.98364711115373899642513899461148, 0.98380771359301145318050106298943, 0.98396673875613702741985032887966, 0.98412420213325197197622049460483, 0.98428011906237796496996312356508, 0.98443450473091545633644070595802, 0.98458737417712237055161477541744, 0.98473874229157830850443230628951, 0.98488862381863439009462110776079, 0.98503703335784887777634715713437, 0.98518398536540871992223491775089, 0.98532949415553715154812350992802, 0.9854735739018874886169613268113, 0.98561623863892325082992969410303, 0.98575750226328474651460304017599, 0.98589737853514225193315117752266, 0.98603588107953591605864920091703, 0.98617302338770252060406859177153, 0.9863088188183892238365455564027, 0.98644328059915441546901144180249, 0.9865764218276558086920432863108, 0.98670825547292589419087002663594, 0.98683879437663487978568781520913, 0.98696805125434123813779630289015, 0.98709603869672998377943591702371, 0.98722276917083879955150635880539, 0.98734825502127213137051423676197, 0.98747250847140336909405849863034, 0.98759554162456523011280527982865, 0.98771736646522846116615946988159, 0.98783799486016897275868885625523, 0.98795743855962351944454336644501, 0.98807570919843403814782694538581, 0.98819281829718075559774578195557, 0.98830877726330417487851124750524, 0.98842359739221605002526352101293, 0.98853728986839945653856679200889, 0.98864986576649806464130253640434, 0.98876133605239472106299905786275, 0.98887171158427944410755166780275, 0.98898100311370693574099622166529, 0.98908922128664371342636358009088, 0.98919637664450496343250841118256, 0.98930247962518121635317424843645, 0.98940754056405494459138816353613, 0.98951156969500718059234284781829, 0.98961457715141425364526267985655, 0.98971657296713474212130558663471, 0.98981756707748673707011076959233, 0.98991756932021551216220833217682, 0.99001658943645169403806125075455, 0.99011463707166002620686077458566, 0.99021172177657881872938954516709, 0.99030785300815017501907088002576, 0.99040304013044108620384695883785, 0.99049729241555548260850838276646, 0.9905906190445373310425889994287, 0.9906830291082648657128420798912, 0.99077453160833603972146808187121, 0.9908651354579452832617365093387, 0.99095484948275165378126107504447, 0.99104368242173846254982772077028, 0.99113164292806446124351937568369, 0.99121873956990667133942174718583, 0.99130498083129493830588092731863, 0.99139037511293829177155698705424, 0.99147493073304319206267249692254, 0.99155865592812374271157341808637, 0.99164155885380394776114929129864, 0.99172364758561209191846096811861, 0.99180493011976732084733550734361, 0.99188541437395849813337677322041, 0.99196510818811541470590763667261, 0.99204401932517242575965329528362, 0.99212215547182458948445538743995, 0.99219952423927638118391372386268, 0.99227613316398305564350718639638, 0.99235198970838472989537154876985, 0.99242710126163325782048980475478, 0.99250147514031196732945762299853, 0.99257511858914833017016819087327, 0.99264803878171963372476162972035, 0.9927202428211517234786916866031, 0.99279173774081088417206439196768, 0.99286253050498892697704817783452, 0.9929326280095815493854684864649, 0.99300203708276003383725699403186, 0.99307076448563635047347272749636, 0.9931388169129217287569063745467, 0.99320620099357876206874883856947, 0.99327292329146710876158953952775, 0.99333899030598285252679643305308, 0.99340440847269158431820258643689, 0.99346918416395526746395363303058, 0.99353332368955294699418281790366, 0.99359683329729536361391700649699, 0.99365971917363353215816380351768, 0.99372198744426134377951163687342, 0.993783644174712250537566307909, 0.99384469537095009048435423537935, 0.99390514697995411077011189986484, 0.99396500489029824572981164638359, 0.99402427493272470635217066349253, 0.99408296288071193697978240569526, 0.99414107445103699454123914381395, 0.99419861530433240507375185266594, 0.99425559104563755175770347162842, 0.994312007224944648152706020332, 0.99436786933773934979811413218634, 0.99442318282553605681942342711671, 0.99447795307640795966565931525695, 0.99453218542551187959140116135157, 0.99458588515560795499087205707242, 0.99463905749757422418999160817411, 0.99469170763091615480593445376685, 0.99474384068427116929197174337709, 0.99479546173590821579865972504061, 0.9948465758142224330002743642541, 0.99489718789822495705814575047632, 0.99494730291802791841976269695939, 0.99499692575532467568457359536299, 0.99504606124386533330385260824616, 0.99509471416992758942312183771748, 0.9951428892727829597211736974328, 0.99519059124515842264971175723109, 0.99523782473369353103209892561113, 0.99528459433939303453843737440111, 0.9953309046180750571173159345639, 0.99537676008081487303197004713373, 0.99542216519438432472014461139604, 0.99546712438168692527286615289468, 0.99551164202218868790717757659439, 0.99555572245234472439208162020827, 0.99559936996602165397503791923405, 0.99564258881491586394854697272608, 0.99568538320896766259257600897929, 0.99572775731677136482872760527711, 0.99576971526598135052606566737499, 0.995811261143714135006524062631, 0.99585239899694649090959259763809, 0.99589313283290966019152960663871, 0.99593346661947969465376296280567, 0.99597340428556396301822324347362, 0.9960129497214838621941123444091, 0.99605210677935377001109602369017, 0.99609087927345627632795422660555, 0.99612927098061372906339808235057, 0.99616728564055613133695963771225, 0.99620492695628542555259790037298, 0.99624219859443619990589462844578, 0.99627910418563285244733460734834, 0.99631564732484324748929866849912, 0.99635183157172889880280850728104, 0.99638766045099171371193408436399, 0.99642313745271733185883738392579, 0.99645826603271509208090058460656, 0.99649304961285466051301088509834, 0.99652749158139935270299555426158, 0.99656159529333618220625050072522, 0.99659536407070266780686815149266, 0.99662880120291043119689514626803, 0.99666190994706561663285806240719, 0.99669469352828616377918756123757, 0.99672715514001596464173567112581, 0.99675929794433593519116611090411, 0.99679112507227203197552585411739, 0.99682263962410024372383213394472, 0.99685384466964858764785577392842, 0.99688474324859613985767905702357, 0.99691533837076912901769366421137, 0.9969456330164341220837329869098, 0.99697563013658833067887761320901, 0.99700533265324706638497584224243, 0.99703474345972837294935566337868, 0.99706386542093486313119520738632, 0.99709270137363278763981173510564, 0.99712125412672836334757091986561, 0.99714952646154138769317707004554, 0.99717752113207616592681576938705, 0.99720524086528977758691204737834, 0.99723268836135770833913632153861, 0.99725986629393687305167907508154, 0.99728677731042605572676159754233, 0.99731342403222379165674328030998, 0.99733980905498371692411360476062, 0.9973659349488674101179304906592, 0.99739180425879475089508295567105, 0.99741741950469181977287849954695, 0.99744278318173636329996036943193, 0.99746789776060084851549651663468, 0.99749276568769313037171404642809, 0.9975173893853947555624433344641, 0.99754177125229692597003401160087, 0.99756591366343414471515481048977, 0.99758981897051556756820039290607, 0.99761348950215408225759024974436, 0.99763692756409313798888627059699, 0.99766013543943134726961649926834, 0.9976831153888448819175990398134, 0.99770586965080768491583226247631, 0.9977284004418095195641871960173, 0.99775070995657187716756427873973, 0.99777280036826176429151867665163, 0.99779467382870339040991891172083, 0.99781633246858777656460372739071, 0.99783777839768030545459102263132, 0.99785901370502623317181131342445, 0.99788004045915418260186942748841, 0.99790086070827763831167263869174, 0.99792147648049446255118078903029, 0.99794188978398445180371318217247, 0.99796210260720495312845616993081, 0.9979821169190845593497830763537, 0.99800193466921490196088819521053, 0.99802155778804056042397791793343, 0.99804098818704710636572390604338, 0.99806022775894730098510218838175, 0.99807927837786546381076410578927, 0.99809814189952003076705921444064, 0.99811682016140431933138601694056, 0.99813531498296551839095503275663, 0.99815362816578192023409848836952, 0.99817176149373841194007091666937, 0.99818971673320024326169307721906, 0.99820749563318508792735997144075, 0.99822509992553341512268365854856, 0.99824253132507718774742105562355, 0.99825979152980690388042202922388, 0.99827688222103699772386577599119, 0.9982938050635696161383315308752, 0.99831056170585678672197855755414, 0.99832715378016099323045560250036, 0.99834358290271417397901730717299, 0.99835985067387515871472755923544, 0.99837595867828555929450794032474, 0.99839190848502412935417638196596, 0.99840770164775960800454995995316, 0.99842333970490206244290663236333, 0.99843882417975274422201566710904, 0.99845415658065247377406416628586, 0.99846933840112856764349805344567, 0.99848437112004032274084011628429, 0.99849925620172307178899316754693, 0.99851399509613082399432685294599, 0.99852858923897750483710121056068, 0.99854304005187680873925888917024, 0.99855734894248067823254761074812, 0.99857151730461642311611814593001, 0.99858554651842249296028167669617, 0.99859943795048291618194273641521, 0.99861319295396041878730362166631, 0.99862681286872823574888237689859, 0.99864029902150062785646589706783, 0.99865365272596211675561196195761, 0.998666875282895450762358458199, 0.99867996798030831391924538562777, 0.9986929320935587906352928092913, 0.99870576888547959813137445198214, 0.99871847960650109879241264146128, 0.9987310654947731044089280027304, 0.99874352777628548417288032674872, 0.99875586766498758817611781550913, 0.99876808636290649804443796291549, 0.99878018506026411622599990980675, 0.99879216493559310533968469292773, 0.99880402715585168887701775067987, 0.99881577287653732444031169547899, 0.99882740324179926058992380398331, 0.99883891938454998826470375815164, 0.99885032242657559763208931803691, 0.99886161347864505111766417392767, 0.99887279364061838325839434845152, 0.99888386400155383791928991661148, 0.99889482563981395330963609436536, 0.99890567962317060513252782344021, 0.9989164270089090180999138316895, 0.99892706884393075594486528440376, 0.99893760616485569996329582099139, 0.99894803999812302601881609071165, 0.99895837136009118984687468947684, 0.99896860125713693039769954313748, 0.99897873068575330086193666693681, 0.99898876063264673692815285270993, 0.9989986920748331717275748257459, 0.99900852597973320682861616797374, 0.99901826330526634855175254821138, 0.9990279049999443187842712650828, 0.99903745200296344938428985430338, 0.99904690524429616917413443874123, 0.99905626564478159243483222768642, 0.99906553411621521772586256436208, 0.99907471156143774576777293938721, 0.99908379887442302503931239608967, 0.9990927969403651336559073817502, 0.99910170663576460601205013602506, 0.99911052882851381258693383147614, 0.99911926437798150123017561300859, 0.99912791413509650816273662105101, 0.99913647894243064684733750055038, 0.99914495963428078280254222063836, 0.99915335703675010235539445938999, 0.99916167196782858324897482435234, 0.99916990523747267494352032608124, 0.99917805764768419637272211764481, 0.99918612999258845884062094374643, 0.99919412305851162166904447530803, 0.99920203762405728813077177595319, 0.99920987446018234912961387795316, 0.99921763433027208201535094759593, 0.99922531799021451184885164268501, 0.99923292618847404236091091387238, 0.99924045966616436377718842523801, 0.9992479191571206446111539813392, 0.99925530538797101445726796187362, 0.99926261907820734474748900950303, 0.99926986094025533436585955417524, 0.99927703167954390694819848053254, 0.99928413199457392662688063890212, 0.9992911625769862389142735320659, 0.99929812411162904335270186267489, 0.99930501727662460449368504218507, 0.99931184274343530770476035555809, 0.99931860117692906623835109576447, 0.99932529323544408593402013830541, 0.99933191957085299386276402478905, 0.99933848082862633716016425636366, 0.99934497764789545823376455882604, 0.99935141066151475246936587457037, 0.99935778049612331450073194028346, 0.99936408777220597904765950316216, 0.99937033310415376226841737489421, 0.99937651710032370951409339694886, 0.99938264036309815531463794907749, 0.99938870348894340136911533858865, 0.99939470706846781825593974410847, 0.99940065168647937652282428359187, 0.9994065379220426127604843231515, 0.99941236634853503620920638751461, 0.9994181375337029813927852232381, 0.99942385203971691222047052740637, 0.999429510423226182944064466878, 0.99943511323541326130443111094783, 0.99944066102204741914928197156946, 0.99944615432353789575224589268245, 0.99945159367498653901183383564663, 0.99945697960623992965809209403444, 0.99946231264194099354433735630959, 0.99946759330158010705152278556866, 0.9994728220995457005834164922043, 0.99947799954517436508185762264455, 0.99948312614280046644296025840468, 0.99948820239180527266721178371944, 0.99949322878666559852890905180536, 0.99949820581700197250343648876343, 0.99950313396762633064427533789212, 0.99950801371858924205565358565173, 0.9995128455452266705610063313691, 0.99951762991820627712233005630395, 0.99952236730357326752073730677952, 0.99952705816279578976422112991647, 0.99953170295280988564478313879299, 0.99953630212606400082365541041724, 0.99954085613056305778034295421289, 0.99954536540991209591860872408849, 0.99954983040335948308040145600886, 0.99955425154583970267692917663432, 0.99955862926801572060478837241518, 0.99956296399632093607409351587255, 0.99956725615300072043502806758775, 0.99957150615615354804912146707495, 0.9995757144197717232117907449437, 0.99957988135378170709336453115988, 0.99958400736408404862681228577648, 0.999588092852592923231864888128, 0.99959213821727528322697050640282, 0.99959614385218962374273082423651, 0.99960011014752436791299141922059, 0.99960403748963587508269577933373, 0.99960792626108607573487238921549, 0.99961177684067973680275649539101, 0.9996155896035013609970724203539, 0.99961936492095172374283261304029, 0.99962310316078405128469397415429, 0.99962680468713984348500497295573, 0.99963046986058434480401324137119, 0.99963409903814166691746798009711, 0.99963769257332956639290236466319, 0.99964125081619388081229926091611, 0.99964477411334262669552637867094, 0.99964826280797976254606310654112, 0.99965171723993862030781469720259, 0.99965513774571500848963214651957, 0.99965852465849999018204330421879, 0.99966187830821233915915870268118, 0.99966519902153067722724633119605, 0.99966848712192529595050324961124, 0.99967174292968966585376592727469, 0.9996749667619716361714559835374, 0.99967815893280432818193705126202, 0.99968131975313672513659726466826, 0.99968444953086396176341505519875, 0.99968754857085731629550359773883, 0.99969061717499390794615807575026, 0.99969365564218610272323172970646, 0.99969666426841063044725465353716, 0.99969964334673741580958847168606, 0.99970259316735812627903569710291, 0.9997055140176144396377576037592, 0.9997084061820260339000376347273, 0.99971126994231830234038517827756, 0.99971410557744979633070532546425, 0.99971691336363939865970441628598, 0.99971969357439322998153745873109, 0.99972244648053129101459933924755, 0.99972517235021384308569267440825, 0.99972787144896752958931806450843, 0.99973054403971124090652905489424, 0.99973319038278172530289928310567, 0.99973581073595894830032229101229, 0.99973840535449120299291136785175, 0.99974097449111997375299069346376, 0.99974351839610455574914772602386, 0.99974603731724643267452706416411, 0.99974853149991341506001107057973, 0.99975100118706354152357296372175, 0.99975344661926874528404448667188, 0.99975586803473828824464390293969, 0.99975826566934196492895855502848, 0.99976063975663307852970264040777, 0.99976299052787119130832135541375, 0.99976531821204465156156249286449, 0.99976762303589289934938007470534, 0.99976990522392855315693029776108, 0.99977216499845927964216318329036, 0.99977440257960944859931433629903, 0.99977661818534157524769340340642, 0.99977881203147755193450119199565, 0.99978098433171967131980068995923, 0.99978313529767144309155754862514, 0.99978526513885820623846253216785, 0.99978737406274753888840437391333, 0.99978946227476946770069351766848, 0.99979152997833647878064388388995, 0.99979357737486333206577204597965, 0.99979560466378668111372066209119, 0.99979761204258450020307057180421, 0.99979959970679532063945543689787, 0.99980156785003727814074319136456, 0.99980351666402697315672651523644, 0.99980544633859814596048385526025, 0.99980735706172016833055486735322, 0.99980924901951635362519712837422, 0.99981112239628208703232238686021, 0.99981297737450277776114957797385, 0.99981481413487163492432871618893, 0.99981663285630726884205960708121, 0.99981843371597111948274564725518, 0.99982021688928471373790639958401, 0.99982198254994675321234703895419, 0.99982373086995003419413841312886, 0.99982546201959820145254854562932, 0.99982717616752233749592811378367, 0.99982887348069738890550843993013, 0.99983055412445843134519197472411, 0.99983221826251677483171370911079, 0.99983386605697591083397779495151, 0.99983549766834730275498313181541, 0.99983711325556602133448688642355, 0.99983871297600622649544066708009, 0.99984029698549649714229353920144, 0.99984186543833501040441810222606, 0.99984341848730457180330618420883, 0.99984495628368749780757104642482, 0.99984647897728035222549600060031, 0.99984798671640853787060213018297, 0.99984947964794074492158617964634, 0.99985095791730325738405657175258, 0.99985242166849411904765843541117, 0.99985387104409716031848207018835, 0.99985530618529588729311494433947, 0.9998567272318872344272771449785, 0.99985813432229518213866424549805, 0.99985952759358424067050743392167, 0.99986090718147280152930452708182, 0.99986227322034635779728305848971, 0.9998636258432705946073816503827, 0.99986496518200435105590648684271, 0.99986629136701245481545814009674, 0.99986760452747843069836261503672, 0.99986890479131708440854691873197, 0.9998701922851869627076332892583, 0.99987146713450269120899074025506, 0.99987272946344719100159268349656, 0.99987397939498377529366431305792, 0.99987521705086812725448320141017, 0.99987644255166016022107136145072, 0.99987765601673576142510028166067, 0.99987885756429842038394016454585, 0.99988004731139074308859946227523, 0.99988122537390585311012559335497, 0.99988239186659868073507261797634, 0.99988354690309714122967985219811, 0.99988469059591320332166363368938, 0.99988582305645384897778268432445, 0.99988694439503192554477772722106, 0.99988805472087689131077916767315, 0.99988915414214545553393027232703, 0.99989024276593211397463186893209, 0.9998913206982795809577180224401, 0.99989238804418911898071601966638, 0.99989344490763076687439962940184, 0.99989449139155346751198626632471, 0.99989552759789509605348027468758, 0.99989655362759238970204112850884, 0.99989756958059077993960876469424, 0.99989857555585412819957351728003, 0.99989957165137436592480690297539, 0.99990055796418103995012328329476, 0.99990153459035076413895153593054, 0.99990250162501657819493493158673, 0.99990345916237721456007677139458, 0.99990440729570627430213067866707, 0.99990534611736131288504059280261, 0.99990627571879283670750875768611, 0.99990719619055321128599526499746, 0.99990810762230548194994598741806, 0.99990901010283210790842816910438, 0.99990990372004361053898187299865, 0.9999107885609871367411128362189, 0.99991166471185493818857882428415, 0.99991253225799276730642917814352, 0.9999133912839081907906591497813, 0.9999142418732788214802822286425, 0.99991508410896046938370754266132, 0.99991591807299521265338833612898, 0.99991674384661938929495684429801, 0.99991756151027151038930193047404, 0.99991837114360009559841924609877, 0.99991917282547143171829000863881, 0.99991996663397725503455850755191, 0.99992075264644235822932058819901, 0.99992153093943212258004128492923, 0.9999223015887599761842859912539, 0.99992306466949477893678617092115, 0.99992382025596813497820550140384, 0.99992456842178163332791318196627, 0.99992530923981401740605333815801, 0.9999260427822282841433421273053, 0.99992676912047871337004439956159, 0.99992748832531782816893950876024, 0.99992820046680328687021861386652, 0.99992890561430470735969461520791, 0.99992960383651042436509007912192, 0.99993029520143418037858580134632, 0.99993097977642175086744336875985, 0.9999316576281575044180250199954, 0.99993232882267089845225249587607, 0.99993299342534291114924841744028, 0.99993365150091241019868333111589, 0.99993430311348245900622876970919, 0.99993494832652656096538065209058, 0.99993558720289484240391366757287, 0.99993621980482017480726166440059, 0.99993684619392423691516501571914, 0.99993746643122351728211085668689, 0.99993808057713525788626873488045, 0.99993868869148333936588854577634, 0.99993929083350410845643000503257, 0.99993988706185214819610613143693, 0.99994047743460599146187026208221, 0.99994106200927377839244319906558, 0.99994164084279885824943663126629, 0.99994221399156533626227711619283, 0.99994278151140356599722349132315, 0.99994334345759558778550806130466, 0.99994389988488051374035118635014, 0.99994445084745985988738931366773, 0.99994499639900282592795444374505, 0.99994553659265152314945825522811, 0.99994607148102615099217930026614, 0.99994660111623012277665790398179, 0.99994712554985514109103130791789, 0.99994764483298622333268513108171, 0.99994815901620667789374828945683, 0.99994866814960303147519064580198, 0.99994917228276990800945854422366, 0.99994967146481485966693297460599, 0.99995016574436315041677852812788, 0.99995065516956249260815218089229, 0.99995113978808773703317325134966, 0.99995161964714551692850307510596, 0.9999520947934788463678996217861, 0.9999525652733716734936984428745, 0.99995303113265338903072441648185, 0.99995349241670329052182087218921, 0.99995394917045500271985983323988, 0.99995440143840085456681562649837, 0.99995484926459621318626218074967, 0.9999552926926637753114820349023, 0.99995573176579781656718623503636, 0.99995616652676839901880765784899, 0.99995659701792553739917619701289, 0.99995702328120332441845679541567, 0.99995744535812401555915330582752, 0.99995786328980207375410830291688, 0.9999582771169481743414783549282, 0.99995868687987317068679967551419, 0.99995909261849202085844742795193, 0.99995949437232767573898692315491, 0.99995989218051492895114135493836, 0.99996028608180422897340652737955, 0.99996067611456545381666538411142, 0.9999610623167916486294559976886, 0.99996144472610272659601627031033, 0.99996182337974913348757245887748, 0.9999621983146154762238595157044, 0.99996256956722411579831759446218, 0.99996293717373872491695972777538, 0.9999633011699678106974546853792, 0.99996366159136820277156269198078, 0.9999640184730485071307314548231, 0.99996437184977252605123707757444, 0.99996472175596264443206648308594, 0.99996506822570318287535645321576, 0.99996541129274371783602471164336, 0.99996575099050236916403224971093, 0.99996608735206905535948512785589, 0.99996642041020871685767213173447, 0.99996675019736450765804927845109, 0.99996707674566095560803226453603, 0.99996740008690709164944700988389, 0.99996772025259954833248578624205, 0.99996803727392562789894592440422, 0.9999683511817663402336643949839, 0.99996866200669941098003076787776, 0.99996896977900226011262878911199, 0.99996927452865495125714017492439, 0.99996957628534311204478879546078, 0.99996987507846082578582574796717, 0.99997017093711349474370204624585, 0.99997046389012067528886746381815, 0.99997075396601888520834316084971, 0.99997104119306438344455054896061, 0.99997132559923592253414418893749, 0.99997160721223747401500082360273, 0.99997188605950092706680018696395, 0.99997216216818876064810867553776, 0.99997243556519668939024653339367, 0.99997270627715628350566321437133, 0.99997297433043756296605080819672, 0.99997323975115156620286115732418, 0.99997350256515289358048023266469, 0.99997376279804222588979043549286, 0.99997402047516881810745432340955, 0.99997427562163296866384781701613, 0.99997452826228846446016384837337, 0.99997477842174500187285325629521, 0.99997502612437058398123708419971, 0.99997527139429389425180833052473, 0.99997551425540664691043336780659, 0.99997575473136591423141000653161, 0.99997599284559643097007932243672, 0.99997622862129287616346655881017, 0.99997646208142213252122776927502, 0.99997669324872552362697691174782, 0.99997692214572102916792570647787, 0.99997714879470547840861955584157, 0.99997737321775672212244682172638, 0.9999775954367357831924646303588, 0.99997781547328898609105943629109, 0.99997803334885006544584795797716, 0.99997824908464225389723555517516, 0.99997846270168034945099936485688, 0.99997867422077276252727166138854, 0.99997888366252354290534841486355, 0.99997909104733438676172804641159, 0.99997929639540662399693745782041, 0.9999794997267431860446758203054, 0.9999797010611505543550116253333, 0.99997990041824068974139153874197, 0.99998009781743294277942461746925, 0.99998029327795594544352774821314, 0.99998048681884948416569175255337, 0.99998067845896635449882600368977, 0.9999808682169741975653444180243, 0.99998105611135731846987393777344, 0.99998124216041848685324277640164, 0.99998142638228071976309086440229, 0.99998160879488904701482696767459, 0.99998178941601225921486031445429, 0.99998196826324463861638682297596, 0.99998214535400767297635069773572, 0.99998232070555175258049982452284, 0.9999824943349578506018668619735, 0.99998266625913918695634529436895, 0.9999828364948428758174431779854, 0.99998300505865155695069423727585, 0.99998317196698501102662936091645, 0.9999833372361017590696812636169, 0.99998350088210064619878869484469, 0.99998366292092240981399584848397, 0.99998382336835123238179910842679, 0.99998398224001627897048945074064, 0.99998413955139321968528463953981, 0.99998429531780573715151176083184, 0.99998444955442701919272751879389, 0.99998460227628123684914832405168, 0.9999847534982450078803708857429, 0.99998490323504884589495450338382, 0.99998505150127859524800854082005, 0.99998519831137685184656040780952, 0.99998534367964437000112279858103, 0.99998548762024145546047603839294, 0.99998563014718934476537775247104, 0.99998577127437157105555384113903, 0.99998591101553531646302441703182, 0.99998604938429275122348494513485, 0.99998618639412235963620385749972, 0.99998632205837025300157773422951, 0.9999864563902514696642609150199, 0.99998658940285126228848607761981, 0.99998672110912637249097967279686, 0.99998685152190629295562706266839, 0.99998698065389451715284279737016, 0.99998710851766977678536234847762, 0.99998723512568726708101356473681, 0.99998736049027986005181181452287, 0.99998748462365930583755810914156, 0.99998760753791742225098460928889, 0.99998772924502727264028754201195, 0.99998784975684433218382545560753, 0.99998796908510764273054147567246, 0.99998808724144095629864913900443, 0.99998820423735386734393851377673, 0.99998832008424293390801541247666, 0.99998843479339278775566815590984, 0.99998854837597723360951409900017, 0.99998866084306033758899783123583, 0.99998877220559750495976244523326, 0.99998888247443654729838129112562, 0.99998899166031873917640200435538, 0.99998909977387986446663219921331, 0.99998920682565125237358209703539, 0.99998931282606080328900990229115, 0.99998941778543400457245363989043, 0.99998952171399493635574312069646, 0.99998962462186726746942691104909, 0.99998972651907524158816575320779, 0.99998982741554465369111817966451, 0.99998992732110381693245401793727, 0.99999002624548452001618353347348, 0.99999012419832297516853704622638, 0.99999022118916075680025966246335, 0.99999031722744573095025270363409, 0.99999041232253297560107689800798, 0.99999050648368569195600356581584, 0.9999905997200761067663371903989, 0.99999069204078636579694860064624, 0.99999078345480941851701334974341, 0.99999087397104989410215909058836, 0.99999096359832496883334066497622, 0.99999105234536522497693444304134, 0.99999114022081550122973446680619, 0.99999122723323573481165614023731, 0.99999131339110179528821370874106, 0.99999139870280631020397584883328, 0.99999148317665948260741786713546, 0.99999156682088990054681642115765, 0.99999164964364533861604188966265, 0.99999173165299355162832100754693, 0.99999181285692306049526813911995, 0.99999189326334393038777715142066, 0.9999919728800885412545188162627, 0.9999920517149123507731600124342, 0.99999212977549464980857065780841, 0.99999220706943931045163744588245, 0.99999228360427552671155238126512, 0.99999235938745854793370460916715, 0.99999243442637040501463732637373, 0.99999250872832062948481191404587, 0.99999258230054696552920013120334, 0.99999265515021607501509655047626, 0.99999272728442423559579730079978, 0.99999279871019803195817575935083, 0.9999928694344950402814562617253, 0.999992939464204505973896292397, 0.99999300880614801475335804419916, 0.99999307746708015713717451786311, 0.99999314545368918640600395732192, 0.99999321277259767010580393367018, 0.99999327943036313515134005226078, 0.9999933454334787065941148618273, 0.99999341078837374011690605844507, 0.99999347550141444831655052049463, 0.99999353957890452083595392938502, 0.99999360302708573840575813722879, 0.99999366585213858085545655050525, 0.99999372806018282915321178571168, 0.99999378965727816153299623265281, 0.99999385064942474376712360436984, 0.99999391104256381364169526786715, 0.99999397084257825969186807305792, 0.99999403005529319425332761920269, 0.99999408868647652088579834146574, 0.99999414674183949622384442814667, 0.99999420422703728630969776408095, 0.99999426114766951746232466319502, 0.99999431750928082173635254624396, 0.99999437331736137702402773350683, 0.99999442857734744185279649578562, 0.99999448329462188493060188996403, 0.999994537474514709490487633931, 0.99999459112230357248558576933293, 0.99999464424321429868505531736114, 0.9999946968424213897210544049423, 0.99999474892504852813633368469298, 0.99999480049616907648154090927115, 0.99999485156080657151087984322609, 0.99999490212393521352421744752217, 0.99999495219048035090335607755183, 0.99999500176531895988963322444342, 0.99999505085328011964960104788512, 0.99999509945914548267505487520896, 0.99999514758764974056324474447629, 0.99999519524348108522261106966129, 0.99999524243128166554901989219829, 0.99999528915564803961692228087053, 0.99999533542113162242954149594062, 0.99999538123223912927167206399801, 0.99999542659343301470827455458248, 0.99999547150913190727165611167094, 0.99999551598371103987954702835976, 0.99999556002150267602602300232748, 0.99999560362679653178678099521594, 0.9999956468038401936798762636512, 0.99999568955683953242262115676433, 0.99999573188995911262495088273934, 0.99999577380732259845917432638879, 0.99999581531301315534561606381269, 0.99999585641107384769326859966942, 0.99999589710550803273422478236923, 0.99999593740027975049023021858191, 0.99999597729931410990935305567707, 0.99999601680649767121038468891092, 0.99999605592567882447220775581432, 0.99999609466066816450501871001821, 0.99999613301523886203992003547699, 0.99999617099312703127303485694215, 0.99999620859803209379994928668102, 0.99999624583361713897592719668864, 0.99999628270350928073701785084039, 0.99999631921130001091679467399038, 0.99999635536054554909314414330365, 0.99999639115476718899920284103305, 0.99999642659745164153215689614721, 0.99999646169205137439334176389131, 0.99999649644198494839270806108703, 0.999996530850637350450434624847, 0.99999656492136032332809607674247, 0.99999659865747269212153243975034, 0.99999663206226068754720605019768, 0.99999666513897826605355141987448, 0.99999669789084742678848621379572, 0.99999673032105852545396861332429, 0.99999676243277058507816373392732, 0.99999679422911160373550879723638, 0.99999682571317885924463423047579, 0.99999685688803921087383151416608, 0.99999688775672939808344261601543, 0.99999691832225633633430762089584, 0.99999694858759740999102997244108, 0.99999697855570076234864172515281, 0.99999700822948558281089220951494, 0.99999703761184239124814363023906, 0.99999706670563331956256925891039, 0.99999709551369239048808022142403, 0.99999712403882579365215045461151, 0.99999715228381215892641327579813, 0.99999718025140282709267139846035, 0.99999720794432211785067271393781, 0.99999723536526759519377089422207, 0.99999726251691033017831855560303, 0.99999728940189516111238098824178, 0.9999973160228409511891235374447, 0.99999734238234084358996267897861, 0.99999736848296251408234087455682, 0.99999739432724842113671563274595, 0.99999741991771605358714309666785, 0.99999744525685817585956185590787, 0.99999747034714307079168415669317, 0.99999749519101478006813864097059, 0.99999751979089334229427382571909, 0.99999754414917502873183962793009, 0.99999756826823257671948465364162, 0.99999759215041542080081671787169, 0.99999761579804992158255237789172, 0.99999763921343959234501821884647, 0.9999976623988653234271177382163, 0.99999768535658560440757658187488, 0.99999770808883674410416142484841, 0.99999773059783308841224022635971, 0.99999775288576723600396887067953, 0.99999777495481025190905998742336, 0.99999779680711187899797393964652, 0.99999781844480074738811388773903, 0.99999783986998458179343974663803, 0.99999786108475040683767928022043, 0.99999788209116475035114914061584, 0.99999790289127384467099186502684, 0.9999979234871038259644197756842, 0.99999794388066093159440121860959, 0.9999979640739316955470045468155, 0.99999798406888314193944485436571, 0.999998003867462976627660092038, 0.99999802347159977693211580951647, 0.99999804288320317950029126921846, 0.99999806210416406632415905615647, 0.99999808113635474893077840233401, 0.99999809998162915076393715571643, 0.99999811864182298777461850514077, 0.99999813711875394723786839481999, 0.99999815541422186481350721319911, 0.99999817353000889986789773034934, 0.99999819146787970907389026821879, 0.99999820922958161830581131642967, 0.9999982268168447928462708164446, 0.9999982442313824059213648135776, 0.99999826147489080558066819659054, 0.99999827854904967993830636549744, 0.99999829545552222079116471198874, 0.99999831219595528563021869627128, 0.99999832877197955806071418685233, 0.99999834518520970664687148151424, 0.99999836143724454219655812587738, 0.99999837752966717350126480374691, 0.99999839346404516154653328498156, 0.99999840924193067220790104420027, 0.99999842486486062744718562690375, 0.99999844033435685502387890002859, 0.99999845565192623673619798518626, 0.99999847081906085520627846147416, 0.99999848583723813922375223364554, 0.99999850070792100766191771983951, 0.99999851543255801198049494611319, 0.9999985300125834773288472928157, 0.99999854444941764226343252383585, 0.99999855874446679709306209565893, 0.99999857289912342086548487744208, 0.9999985869147663170085980007189, 0.99999860079276074763952965470189, 0.99999861453445856655465997213829, 0.99999862814119835091353861719584, 0.99999864161430553162952864667893, 0.99999865495509252247987717570043, 0.99999866816485884794777937567506, 0.9999986812448912698089113426328, 0.99999869419646391247473862900595, 0.9999987070208383871048294770658, 0.99999871971926391450024297350724, 0.99999873229297744678997962661853, 0.99999874474320378792234951857525, 0.999998757071155712972969255971, 0.99999876927803408628104931086061, 0.99999878136502797842543812996706, 0.99999879333331478205185133939515, 0.99999880518406032656255059043373, 0.9999988169184189916796472565219, 0.99999882853753381989309369489173, 0.99999884004253662780431394419744, 0.99999885143454811637633308521283, 0.99999886271467798010111890789063, 0.99999887388402501509479162543473, 0.99999888494367722613122833586067, 0.99999889589471193262447478059506, 0.99999890673819587357030084904864, 0.99999891747518531145712709025633, 0.99999892810672613515642045250247, 0.99999893863385396180261114973501, 0.99999894905759423767243531542322, 0.99999895937896233807353034953616, 0.99999896959896366625202880061906, 0.99999897971859375132876758476897, 0.9999989897388383452736631688624, 0.99999899966067351892769250318528, 0.99999900948506575708183842491578, 0.99999901921297205262226230095922, 0.99999902884533999975086079951617, 0.99999903838310788629031239456659, 0.99999904782720478508258189547147, 0.99999905717855064448979173688899, 0.99999906643805637800628604614127, 0.99999907560662395299060597168798, 0.99999908468514647852602692755288, 0.99999909367450829241820087506971, 0.99999910257558504733840540428331, 0.99999911138924379612076406536013, 0.99999912011634307622175607824778, 0.99999912875773299335025579384616, 0.99999913731425530427622316594394, 0.99999914578674349882613836903381, 0.9999991541760228810731380394991, 0.99999916248291064972979241969126, 0.99999917070821597775133529860284, 0.99999917885274009115710901200457, 0.99999918691727634707788915760206, 0.99999919490261031103671232173765, 0.99999920280951983347072258068306, 0.99999921063877512550148801948056, 0.99999921839113883396117729992541, 0.9999992260673661156818920106921, 0.99999923366820471105541579102152, 0.9999992411943950168705022530431, 0.99999924864667015843485019758555, 0.9999992560257560609887508365687, 0.99999926333237152041737684581765, 0.99999927056722827326860366280207, 0.99999927773103106608318561499261, 0.99999928482447772404403667263326, 0.99999929184825921895128786475016, 0.99999929880305973652978016232814, 0.99999930568955674307550770315936, 0.99999931250842105144753119595227, 0.99999931926031688641178373397657, 0.99999932594590194934311845662639, 0.99999933256582748229192929930997, 0.9999993391207383314215586124274, 0.99999934561127300982268392350201, 0.99999935203806375971080663335951, 0.99999935840173661401289099099388, 0.99999936470291145734915040656098, 0.99999937094220208641594838343891, 0.999999377120216269775649001396, 0.99999938323755580705928662449311, 0.99999938929481658758780043025515, 0.99999939529258864841753138017083, 0.99999940123145623181567594285779, 0.99999940711199784217124529744185, 0.99999941293478630234711679500762, 0.99999941870038880947863707016347, 0.99999942440936699022422626859615, 0.99999943006227695547337329948655, 0.99999943565966935451731937742948, 0.99999944120208942868775027955722, 0.99999944669007706446868704903014, 0.99999945212416684608676322169629, 0.99999945750488810758500882391166, 0.99999946283276498438522499356579, 0.9999994681083164643439437408515, 0.99999947333205643830698390892937, 0.99999947850449375016748535446244, 0.99999948362613224643234472702692, 0.99999948869747082530183726006203, 0.99999949371900348526722883835652, 0.99999949869121937323112139570442, 0.99999950361460283215518370649494, 0.99999950848963344823994445041986, 0.99999951331678609764123509397568, 0.99999951809653099272781057543364, 0.99999952282933372788468239739561, 0.99999952751565532486661766735386, 0.99999953215595227770620799583589, 0.9999995367506765971809038899095, 0.99999954130027585484332921612309, 0.99999954580519322661916714589925, 0.99999955026586753597688748970342, 0.9999995546827332966734794471915, 0.99999955905622075508038523340298, 0.99999956338675593209375394045034, 0.99999956767476066463307874587348, 0.99999957192065264673229215935654, 0.99999957612484547022728315730266, 0.99999958028774866504382983326393, 0.99999958440976773908986509160757, 0.99999958849130421775595651585261, 0.99999959253275568302783522099662, 0.99999959653451581221482338840354, 0.99999960049697441629788610473142, 0.99999960442051747790107613977085, 0.99999960830552718889005758000376, 0.9999996121523819876013628018286, 0.99999961596145659570603726839847, 0.99999961973312205471122075489977, 0.99999962346774576210326654665857, 0.99999962716569150713588434917602, 0.9999996308273195062668058840838, 0.9999996344529864382464307859802, 0.9999996380430454788618574755479, 0.99999964159784633533969872127136, 0.99999964511773528041102039070575, 0.99999964860305518604172700299889, 0.99999965205414555683167633533666, 0.9999996554713425630857887923704, 0.99999965885497907356034941887426, 0.99999966220538468788772194257667, 0.99999966552288576868260489860376, 0.99999966880780547333297312186254, 0.99999967206046378547880653466073, 0.99999967528117754618166018038503, 0.99999967847026048478810132991827, 0.99999968162802324949006595725604, 0.99999968475477343758504956880119, 0.99999968785081562543912843451507, 0.99999969091645139815570635306929, 0.9999996939519793789528853918645, 0.99999969695769525825231437502938, 0.99999969993389182248236392942965, 0.99999970288085898259841237862872, 0.9999997057988838023230416639931, 0.999999708688250526108874643325, 0.99999971154924060682680331537843, 0.99999971438213273318226983746991, 0.99999971718720285686230521678675, 0.99999971996472421941595280101861, 0.99999972271496737887068715032531, 0.99999972543820023608744879882156, 0.99999972813468806085683104133676, 0.99999973080469351773897804226498, 0.99999973344847669164970724120615, 0.99999973606629511319535910393204, 0.99999973865840378375881109276152, 0.99999974122505520033913739818291, 0.99999974376649938014731821858334, 0.99999974628298388496037259644329, 0.99999974877475384523633679582974, 0.99999975124205198399238116584604, 0.99999975368511864044843784403519, 0.99999975610419179343861570078239, 0.9999997584995070845926838888462, 0.99999976087129784128990205342529, 0.99999976321979509938740908371878, 0.99999976554522762572540213927282, 0.99999976784782194041128309048566, 0.99999977012780233888495778444955, 0.99999977238539091376742887955476, 0.99999977462080757649480810303004, 0.99999977683427007873987047687124, 0.99999977902599403362321019188339, 0.99999978119619293671609751423098, 0.99999978334507818683704842774595, 0.99999978547285910664417000044139, 0.99999978757974296302524189328243, 0.99999978966593498728757052988262, 0.99999979173163839514954325795293, 0.99999979377705440653584457491639, 0.99999979580238226517826836596058, 0.99999979780781925802402370685299, 0.99999979979356073445343674692834, 0.99999980175980012530890651990349, 0.99999980370672896173698576506564, 0.99999980563453689384539828437522, 0.99999980754341170917684572005566, 0.99999980943353935100135902992986, 0.99999981130510393642901611221217, 0.99999981315828777434476596776474, 0.99999981499327138316711798580047, 0.99999981681023350843241357998433, 0.99999981860935114020641559985799, 0.99999982039079953032488476806411, 0.99999982215475220946484217234837, 0.99999982390138100404817051920305, 0.99999982563085605297920851037742, 0.999999827343345824217956307533, 0.99999982903901713119052328521165, 0.99999983071803514903840625889256, 0.99999983238056343070817314002461, 0.99999983402676392288314682225481, 0.99999983565679698175859973065167, 0.99999983727082138866204225761561, 0.9999998388689943655200873931344, 0.99999984045147159017342514223909, 0.99999984201840721154137580242836, 0.99999984356995386463752426105383, 0.99999984510626268543787129820952, 0.99999984662748332560298089406084, 0.99999984813376396705552313020952, 0.99999984962525133641466025116641, 0.99999985110209071928866885808373, 0.99999985256442597442719451562076, 0.99999985401239954773451685484343, 0.99999985544615248614518505708496, 0.99999985686582445136338360369441, 0.99999985827155373346736501554324, 0.99999985966347726438026976254732, 0.9999998610417306312086435972948, 0.99999986240644808944996752995376, 0.99999986375776257607046768515802, 0.99999986509580572245448882518194, 0.99999986642070786722669547137999, 0.99999986773259806894833477736516, 0.99999986903160411868882343154095, 0.99999987031785255247385634651387, 0.9999998715914686636112646714155, 0.99999987285257651489582584774479, 0.99999987410129895069420692264526, 0.99999987533775760891121075300334, 0.99999987656207293283852285789473, 0.99999987777436418288706899576089, 0.9999998789747494482041564084243, 0.99999988016334565817653527810397, 0.99999988134026859382046234967262, 0.99999988250563289905992311665177, 0.99999988365955209189408625137983, 0.99999988480213857545507223159445, 0.99999988593350364895712804183771, 0.99999988705375751853827997575793, 0.99999988816300930799548858890656, 0.9999998892613670694143943717162, 0.99999989034893779369465337683968, 0.99999989142582742097191001150581, 0.99999989249214085093741119215533, 0.99999989354798195305627763914932, 0.99999989459345357668541003903406, 0.99999989562865756109203592598735, 0.99999989665369474537386177504031, 0.99999989766866497828179314530784, 0.99999989867366712794619729198926, 0.99999989966879909150762807198032, 0.99999990065415780465297929005199, 0.99999990162983925105797638426986, 0.99999990259593847173693951038522, 0.99999990355254957430070807153667, 0.99999990449976574212366306171596, 0.99999990543767924342070087339001, 0.99999990636638144023507177667549, 0.99999990728596279733794664662537, 0.99999990819651289104057882390946, 0.99999990909812041791991972236476, 0.99999990999087320345854514253023, 0.99999991087485821059972608922335, 0.99999991175016154821847292813244, 0.99999991261686847950939660564928, 0.99999991347506343029218433405279, 0.99999991432482999723550699648881, 0.99999991516625095600016560002386, 0.99999991599940826930225267218748, 0.99999991682438309489713262055861, 0.99999991764125579348501198772673, 0.99999991845010593653886226215275, 0.99999991925101231405547279470524, 0.99999992004405294223036504853376, 0.99999992082930507105735069513844, 0.99999992160684519185344327760164, 0.99999992237674904470985963172681, 0.99999992313909162586986710816424, 0.9999999238939471950341466118202, 0.99999992464138928259442584726779, 0.99999992538149069679606602134564, 0.99999992611432353083030841518763, 0.9999999268399591698568574594245, 0.99999992755846829795749845299455, 0.99999992826992090502143813983296, 0.9999999289743862935629968007053, 0.99999992967193308547236985295691, 0.99999993036262922870006941747024, 0.99999993104654200387572910401613, 0.99999993172373803086190728970941, 0.99999993239428327524351093038952, 0.99999993305824305475350164941616, 0.99999993371568204563548794572715, 0.99999993436666428894382556097914, 0.99999993501125319678185631739792, 0.99999993564951155847886776148955, 0.99999993628150154670639730779428, 0.99999993690728472353446487219557, 0.99999993752692204642832460174164, 0.99999993814047387418632465357578, 0.99999993874799997281945239504282, 0.9999999393495595213731357795945, 0.99999993994521111769186503567154, 0.99999994053501278412719549701768, 0.99999994111902197318971390957685, 0.99999994169729557314546452334121, 0.9999999422698899135574355022745, 0.99999994283686077077261684992953, 0.99999994339826337335516420943529, 0.99999994395415240746620620525201, 0.99999994450458202219082306792485, 0.99999994504960583481269450456508, 0.9999999455892769360369561368181, 0.99999994612364789516176246904697, 0.99999994665277076519905104073792, 0.99999994717669708794502061510748, 0.99999994769547789900081474919519, 0.99999994820916373274389381891951, 0.99999994871780462725057360949114, 0.99999994922145012917024332316332, 0.99999994972014929855168652079299, 0.99999995021395071362202115791482, 0.99999995070290247551869381233045, 0.99999995118705221297501283105182, 0.99999995166644708695965053051719, 0.99999995214113379527059421483506, 0.99999995261115857708396621980718, 0.99999995307656721745818116695744, 0.9999999535374050517938622896789, 0.99999995399371697024995854594617, 0.9999999544455474221164843797055, 0.99999995489294042014432715411218, 0.99999995533593954483251930330916, 0.99999995577458794867341029974928, 0.99999995620892836035614871864469, 0.99999995663900308892887310059898, 0.99999995706485402792003678325668, 0.99999995748652265941924885941315, 0.99999995790405005811804154316883, 0.99999995831747689531094610157064, 0.99999995872684344285728763332452, 0.99999995913218957710405107352, 0.99999995953355478277024028647916, 0.99999995993097815679307931694857, 0.99999996032449841213643464835468, 0.99999996071415388156184393428814, 0.99999996109998252136250523651922, 0.99999996148202191506059734645876, 0.99999996186030927706828356900558, 0.99999996223488145631276292824993, 0.9999999626057749398257211739738, 0.99999996297302585629753065916674, 0.99999996333666997959653326952458, 0.99999996369674273225378029056789, 0.99999996405327918891352699740082, 0.99999996440631407974985585274706, 0.99999996475588179384973602445085, 0.99999996510201638256286002085546, 0.99999996544475156281858335322036, 0.9999999657841207204102865168937, 0.99999996612015691324747858295633, 0.99999996645289287457596665513771, 0.99999996678236101616639724883016, 0.99999996710859343147148226647311, 0.99999996743162189875221728049521, 0.99999996775147788417340148936332, 0.99999996806819254486875382303654, 0.99999996838179673197591636540088, 0.99999996869232099364167431156824, 0.99999996899979557799763399677881, 0.99999996930425043610669814095781, 0.99999996960571522488059308055537, 0.99999996990421930996874411832872, 0.99999997019979176861878188683638, 0.99999997049246139250894938652381, 0.99999997078225669055270086597637, 0.99999997106920589167575227905165, 0.99999997135333694756584967104876, 0.99999997163467753539554997021235, 0.99999997191325506051824414078176, 0.99999997218909665913771055643855, 0.99999997246222920095145336578095, 0.99999997273267929176807069528657, 0.99999997300047327609892896808804, 0.99999997326563723972437494913303, 0.9999999735281970122347469058022, 0.99999997378817816954643800125258, 0.99999997404560603639323856797419, 0.99999997430050568879321534191098, 0.99999997455290195649136753952383, 0.99999997480281942537828642528333, 0.9999999750502824398850599063313, 0.99999997529531510535467030849474, 0.99999997553794129039008385699931, 0.99999997577818462917929325095579, 0.99999997601606852379752343549526, 0.99999997625161614648681563851213, 0.99999997648485044191324278928248, 0.99999997671579412940194326177625, 0.99999997694446970515020455323468, 0.99999997717089944441881858241723, 0.99999997739510540370191043958735, 0.9999999776171094228754639270027, 0.9999999778369331273247341414504, 0.99999997805459793005077374631545, 0.99999997827012503375627807397401, 0.99999997848353543291093434696892, 0.99999997869484991579648512184288, 0.99999997890408906653172102258873, 0.99999997911127326707757316292287, 0.99999997931642269922251536125746, 0.99999997951955734654847467171853, 0.99999997972069699637742393913834, 0.9999999799198612416988697906204, 0.99999998011706948307839653671568, 0.99999998031234093054747443172455, 0.99999998050569460547471427285914, 0.99999998069714934241872219386006, 0.99999998088672379096278791800023, 0.99999998107443641753152227576162, 0.99999998126030550718968552392368, 0.9999999814443491654233189626268, 0.99999998162658531990340815225993, 0.99999998180703172223221173343148, 0.99999998198570594967244279284203, 0.99999998216262540685946655682012, 0.99999998233780732749668812044966, 0.99999998251126877603427745043816, 0.99999998268302664933142853071142, 0.99999998285309767830226680165931, 0.99999998302149842954561168818572, 0.99999998318824530695872821982193, 0.99999998335335455333522987030347, 0.9999999835168422519472782003983, 0.99999998367872432811226459244341, 0.99999998383901655074408326443091, 0.9999999839977345338891874695455, 0.99999998415489373824754468643917, 0.99999998431050947267866947125552, 0.99999998446459689569284977668929, 0.99999998461717101692773879164868, 0.99999998476824669861044630477954, 0.99999998491783865700525697766593, 0.99999998506596146384715088999671, 0.99999998521262954776122561837188, 0.99999998535785719566819190231591, 0.99999998550165855417605870278391, 0.99999998564404763095815158258719, 0.99999998578503829611760502944237, 0.99999998592464428353843790948486, 0.99999998606287919222337583300801, 0.99999998619975648761852796590763, 0.99999998633528950292505229009092, 0.99999998646949144039794331610934, 0.99999998660237537263205970766209, 0.99999998673395424383552747559091, 0.99999998686424087109062958356809, 0.99999998699324794560232258618203, 0.99999998712098803393447625237113, 0.99999998724747357923399168416149, 0.99999998737271690244287899440816, 0.99999998749673020349844012732795, 0.99999998761952556252166931838703, 0.99999998774111494099396383777188, 0.99999998786151018292230549048253, 0.99999998798072301599297243005212, 0.99999998809876505271393679584796, 0.99999998821564779154603585509903, 0.99999998833138261802304072674176, 0.99999998844598080586070871386787, 0.99999998855945351805496813728446, 0.99999998867181180796929522719051, 0.99999998878306662041142203931264, 0.99999998889322879269947465717368, 0.99999998900230905571762770727776, 0.9999999891103180349614025730262, 0.99999998921726625157269533414796, 0.99999998932316412336463865640186, 0.99999998942802196583640185630761, 0.99999998953184999317802013077317, 0.9999999896346583192653604850981, 0.99999998973645695864530542305272, 0.99999998983725582751128343920889, 0.99999998993706474466918932691408, 0.99999999003589343249383988569666, 0.99999999013375151787603120255133, 0.99999999023064853316028684261086, 0.99999999032659391707340944576755, 0.99999999042159701564389694060953, 0.99999999051566708311234910712522, 0.99999999060881328283291411901263, 0.99999999070104468816589087087916, 0.99999999079237028336156649967085, 0.99999999088279896443537016403103, 0.99999999097233954003443076273335, 0.99999999106100073229562958205647, 0.99999999114879117769522066399445, 0.99999999123571942789010988517011, 0.99999999132179395055086553834538, 0.99999999140702313018656629564687, 0.99999999149141526896151798637014, 0.9999999915749785875039831187891, 0.99999999165772122570693472649921, 0.99999999173965124352097846872099, 0.9999999918207766217394611825374, 0.99999999190110526277588003798954, 0.99999999198064499143366177920216, 0.99999999205940355566836664545945, 0.99999999213738862734242616007188, 0.99999999221460780297244787425865, 0.99999999229106860446919956260908, 0.99999999236677847987031257479226, 0.99999999244174480406579698774363, 0.99999999251597487951642976969384, 0.99999999258947593696508047612755, 0.99999999266225513614106215881729, 0.99999999273431956645756373621383, 0.99999999280567624770222007347485, 0.99999999287633213072090910763807, 0.99999999294629409809484550111015, 0.99999999301556896481099563888992, 0.99999999308416347892593308353404, 0.99999999315208432222316922945084, 0.99999999321933811086401540480398, 0.9999999932859313960320707196158, 0.99999999335187066457137040165606, 0.99999999341716233961826410328752, 0.99999999348181278122709531680102, 0.99999999354582828698973980088305, 0.99999999360921509264904106852383, 0.99999999367197937270624385240069, 0.99999999373412724102244540007155, 0.99999999379566475141415062576206, 0.99999999385659789824296916905462, 0.99999999391693261699952880673453, 0.99999999397667478488164823118489, 0.9999999940358302213668370241407, 0.99999999409440468877916583919391, 0.99999999415240389285058123930456, 0.99999999420983348327669165909756, 0.99999999426669905426710886436775, 0.99999999432300614509038130474003, 0.99999999437876024061356402723766, 0.99999999443396677183651283190377, 0.99999999448863111642090101511474, 0.99999999454275859921407450587126, 0.99999999459635449276773050581601, 0.99999999464942401785152054901278,
	};

	//2D
	double aP2[2000] = { -0.000000000000001, 0, 0.000000000000000, 0.000000000000000, -0.000000000000000, 0.000000000000000, 0.000000000000001, 0.000000000000053, 0.000000000001712, 0.000000000027508, 0.000000000266743, 0.000000001770991, 0.000000008786175, 0.000000034670427, 0.000000113914676, 0.000000322533781, 0.000000807886832, 0.000001827157561, 0.000003791879454, 0.000007314563512, 0.000013252959815, 0.000022747754649, 0.000037250376283, 0.000058538780055, 0.000088720348217, 0.000130222178445, 0.000185769933671, 0.000258357041813, 0.000351206375949, 0.000467726652827, 0.000611465714064, 0.000786062655166, 0.000995200492516, 0.001242560748489, 0.001531781020628, 0.001866416303605, 0.002249904565948, 0.002685536854072, 0.003176432006445, 0.003725515909772, 0.004335505113991, 0.005008894539454, 0.005747948953426, 0.006554697859228, 0.007430933425712, 0.008378211083201, 0.009397852421185, 0.010490950039972, 0.011658374030674, 0.012900779783443, 0.014218616851179, 0.015612138623819, 0.017081412595843, 0.018626331036232, 0.020246621895221, 0.021941859805614, 0.023711477057939, 0.025554774448276, 0.027470931915197, 0.029459018897900, 0.031518004361545, 0.033646766447890, 0.035844101719938, 0.038108733978411, 0.040439322635686, 0.042834470639434, 0.045292731943800, 0.047812618530586, 0.050392606986691, 0.053031144647186, 0.055726655315841, 0.058477544576834, 0.061282204712846, 0.064139019245777, 0.067046367117037, 0.070002626524799, 0.073006178435786, 0.076055409789154, 0.079148716409848, 0.082284505648551, 0.085461198764870, 0.088677233069972, 0.091931063844301, 0.095221166045414, 0.098546035820343, 0.101904191836249, 0.105294176442447, 0.108714556676254, 0.112163925124416, 0.115640900651245, 0.119144129003946, 0.122672283305007, 0.126224064440907, 0.129798201355848, 0.133393451258627, 0.137008599750268, 0.140642460879503, 0.144293877132716, 0.147961719364522, 0.151644886674690, 0.155342306236746, 0.159052933083175, 0.162775749851796, 0.166509766497538, 0.170254019973531, 0.174007573885106, 0.177769518120040, 0.181538968458107, 0.185315066162751, 0.189096977557471, 0.192883893589292, 0.196675029381492, 0.200469623777583, 0.204266938878363, 0.208066259573692, 0.211866893070499, 0.215668168418410, 0.219469436034214, 0.223270067226318, 0.227069453720196, 0.230867007185745, 0.234662158767389, 0.238454358617638, 0.242243075434796, 0.246027796005371, 0.249808024751722, 0.253583283285396, 0.257353109966555, 0.261117059469827, 0.264874702356898, 0.268625624656095, 0.272369427449163, 0.276105726465434, 0.279834151683517, 0.283554346940627, 0.287265969549658, 0.290968689924026, 0.294662191210358, 0.298346168929026, 0.302020330622521, 0.305684395511669, 0.309338094159642, 0.312981168143714, 0.316613369734729, 0.320234461584178, 0.323844216418837, 0.327442416742857, 0.331028854547231, 0.334603331026515, 0.338165656302721, 0.341715649156250, 0.345253136763766, 0.348777954442874, 0.352289945403502, 0.355788960505847, 0.359274858024757, 0.362747503420443, 0.366206769115363, 0.369652534277173, 0.373084684607610, 0.376503112137161, 0.379907715025422, 0.383298397366985, 0.386675069002748, 0.390037645336514, 0.393386047156752, 0.396720200463399, 0.400040036299579, 0.403345490588121, 0.406636503972751, 0.409913021663848, 0.413174993288638, 0.416422372745724, 0.419655118063834, 0.422873191264677, 0.426076558229796, 0.429265188571326, 0.432439055506534, 0.435598135736059, 0.438742409325729, 0.441871859591893, 0.444986472990130, 0.448086239007278, 0.451171150056675, 0.454241201376521, 0.457296390931289, 0.460336719316079, 0.463362189663857, 0.466372807555475, 0.469368580932411, 0.472349520012140, 0.475315637206074, 0.478266947039981, 0.481203466076830, 0.484125212841984, 0.487032207750664, 0.489924473037646, 0.492802032689094, 0.495664912376492, 0.498513139392602, 0.501346742589390, 0.504165752317871, 0.506970200369807, 0.509760119921207, 0.512535545477579, 0.515296512820884, 0.518043058958133, 0.520775222071590, 0.523493041470527, 0.526196557544483, 0.528885811717994, 0.531560846406734, 0.534221704975043, 0.536868431694784, 0.539501071705504, 0.542119670975848, 0.544724276266200, 0.547314935092504, 0.549891695691240, 0.552454606985509, 0.555003718552204, 0.557539080590235, 0.560060743889760, 0.562568759802415, 0.565063180212499, 0.567544057509085, 0.570011444559036, 0.572465394680892, 0.574905961619612, 0.577333199522127, 0.579747162913700, 0.582147906675056, 0.584535486020264, 0.586909956475340, 0.589271373857564, 0.591619794255478, 0.593955274009543, 0.596277869693443, 0.598587638096016, 0.600884636203781, 0.603168921184061, 0.605440550368663, 0.607699581238124, 0.609946071406476, 0.612180078606538, 0.614401660675710, 0.616610875542252, 0.618807781212030, 0.620992435755733, 0.623164897296515, 0.625325223998085, 0.627473474053203, 0.629609705672579, 0.631733977074171, 0.633846346472856, 0.635946872070475, 0.638035612046223, 0.640112624547398, 0.642177967680478, 0.644231699502519, 0.646273878012876, 0.648304561145220, 0.650323806759859, 0.652331672636334, 0.654328216466303, 0.656313495846686, 0.658287568273077, 0.660250491133399, 0.662202321701809, 0.664143117132843, 0.666072934455782, 0.667991830569245, 0.669899862235996, 0.671797086077958, 0.673683558571433, 0.675559336042511, 0.677424474662675, 0.679279030444581, 0.681123059238028, 0.682956616726082, 0.684779758421387, 0.686592539662620, 0.688395015611111, 0.690187241247612, 0.691969271369211, 0.693741160586392, 0.695502963320223, 0.697254733799689, 0.698996526059140, 0.700728393935878, 0.702450391067847, 0.704162570891456, 0.705864986639506, 0.707557691339223, 0.709240737810408, 0.710914178663674, 0.712578066298795, 0.714232452903141, 0.715877390450214, 0.717512930698263, 0.719139125188994, 0.720756025246362, 0.722363681975435, 0.723962146261353, 0.725551468768345, 0.727131699938829, 0.728702889992580, 0.730265088925967, 0.731818346511255, 0.733362712295968, 0.734898235602321, 0.736424965526702, 0.737942950939218, 0.739452240483293, 0.740952882575323, 0.742444925404379, 0.743928416931961, 0.745403404891801, 0.746869936789711, 0.748328059903479, 0.749777821282803, 0.751219267749270, 0.752652445896379, 0.754077402089592, 0.755494182466434, 0.756902832936623, 0.758303399182237, 0.759695926657908, 0.761080460591061, 0.762457045982172, 0.763825727605064, 0.765186550007222, 0.766539557510152, 0.767884794209747, 0.769222303976696, 0.770552130456905, 0.771874317071949, 0.773188907019548, 0.774495943274054, 0.775795468586974, 0.777087525487501, 0.778372156283073, 0.779649403059943, 0.780919307683773, 0.782181911800246, 0.783437256835682, 0.784685383997689, 0.785926334275814, 0.787160148442212, 0.788386867052333, 0.789606530445619, 0.790819178746213, 0.792024851863680, 0.793223589493742, 0.794415431119019, 0.795600416009788, 0.796778583224744, 0.797949971611775, 0.799114619808745, 0.800272566244283, 0.801423849138587, 0.802568506504224, 0.803706576146951, 0.804838095666531, 0.805963102457563, 0.807081633710313, 0.808193726411556, 0.809299417345417, 0.810398743094223, 0.811491740039357, 0.812578444362113, 0.813658892044565, 0.814733118870425, 0.815801160425920, 0.816863052100661, 0.817918829088520, 0.818968526388507, 0.820012178805656, 0.821049820951901, 0.822081487246968, 0.823107211919256, 0.824127029006730, 0.825140972357810, 0.826149075632259, 0.827151372302078, 0.828147895652397, 0.829138678782370, 0.830123754606065, 0.831103155853363, 0.832076915070844, 0.833045064622691, 0.834007636691573, 0.834964663279547, 0.835916176208943, 0.836862207123261, 0.837802787488060, 0.838737948591849, 0.839667721546974, 0.840592137290509, 0.841511226585141, 0.842425020020052, 0.843333548011810, 0.844236840805244, 0.845134928474329, 0.846027840923063, 0.846915607886343, 0.847798258930842, 0.848675823455879, 0.849548330694293, 0.850415809713307, 0.851278289415401, 0.852135798539169, 0.852988365660183, 0.853836019191854, 0.854678787386286, 0.855516698335133, 0.856349779970445, 0.857178060065522, 0.858001566235758, 0.858820325939482, 0.859634366478801, 0.860443715000437, 0.861248398496560, 0.862048443805622, 0.862843877613181, 0.863634726452732, 0.864421016706525, 0.865202774606388, 0.865980026234538, 0.866752797524399, 0.867521114261411, 0.868285002083832, 0.869044486483547, 0.869799592806866, 0.870550346255318, 0.871296771886450, 0.872038894614611, 0.872776739211744, 0.873510330308166, 0.874239692393348, 0.874964849816694, 0.875685826788313, 0.876402647379788, 0.877115335524943, 0.877823915020606, 0.878528409527368, 0.879228842570339, 0.879925237539902, 0.880617617692459, 0.881306006151179, 0.881990425906739, 0.882670899818064, 0.883347450613061, 0.884020100889348, 0.884688873114988, 0.885353789629208, 0.886014872643122, 0.886672144240451, 0.887325626378233, 0.887975340887536, 0.888621309474164, 0.889263553719362, 0.889902095080514, 0.890536954891842, 0.891168154365097, 0.891795714590250, 0.892419656536176, 0.893040001051341, 0.893656768864475, 0.894269980585255, 0.894879656704969, 0.895485817597193, 0.896088483518451, 0.896687674608879, 0.897283410892883, 0.897875712279794, 0.898464598564519, 0.899050089428193, 0.899632204438819, 0.900210963051911, 0.900786384611135, 0.901358488348940, 0.901927293387192, 0.902492818737799, 0.903055083303341, 0.903614105877685, 0.904169905146609, 0.904722499688414, 0.905271907974532, 0.905818148370144, 0.906361239134773, 0.906901198422896, 0.907438044284536, 0.907971794665859, 0.908502467409769, 0.909030080256491, 0.909554650844162, 0.910076196709410, 0.910594735287935, 0.911110283915085, 0.911622859826428, 0.912132480158323, 0.912639161948485, 0.913142922136552, 0.913643777564641, 0.914141744977909, 0.914636841025105, 0.915129082259124, 0.915618485137551, 0.916105066023212, 0.916588841184710, 0.917069826796971, 0.917548038941772, 0.918023493608284, 0.918496206693593, 0.918966194003233, 0.919433471251710, 0.919898054063020, 0.920359957971173, 0.920819198420703, 0.921275790767186, 0.921729750277747, 0.922181092131566, 0.922629831420385, 0.923075983149010, 0.923519562235807, 0.923960583513198, 0.924399061728157, 0.924835011542696, 0.925268447534357, 0.925699384196694, 0.926127835939757, 0.926553817090567, 0.926977341893600, 0.927398424511253, 0.927817079024323, 0.928233319432469, 0.928647159654681, 0.929058613529746, 0.929467694816703, 0.929874417195306, 0.930278794266475, 0.930680839552756, 0.931080566498765, 0.931477988471636, 0.931873118761472, 0.932265970581782, 0.932656557069924, 0.933044891287543, 0.933430986221004, 0.933814854781828, 0.934196509807119, 0.934575964059997, 0.934953230230016, 0.935328320933596, 0.935701248714435, 0.936072026043934, 0.936440665321609, 0.936807178875507, 0.937171578962614, 0.937533877769267, 0.937894087411561, 0.938252219935748, 0.938608287318645, 0.938962301468031, 0.939314274223043, 0.939664217354573, 0.940012142565660, 0.940358061491883, 0.940701985701743, 0.941043926697056, 0.941383895913333, 0.941721904720164, 0.942057964421595, 0.942392086256507, 0.942724281398991, 0.943054560958721, 0.943382935981325, 0.943709417448752, 0.944034016279643, 0.944356743329690, 0.944677609392003, 0.944996625197470, 0.945313801415111, 0.945629148652439, 0.945942677455814, 0.946254398310791, 0.946564321642476, 0.946872457815870, 0.947178817136217, 0.947483409849346, 0.947786246142018, 0.948087336142260, 0.948386689919710, 0.948684317485948, 0.948980228794833, 0.949274433742833, 0.949566942169362, 0.949857763857101, 0.950146908532330, 0.950434385865249, 0.950720205470305, 0.951004376906513, 0.951286909677771, 0.951567813233182, 0.951847096967369, 0.952124770220788, 0.952400842280038, 0.952675322378177, 0.952948219695026, 0.953219543357477, 0.953489302439798, 0.953757505963937, 0.954024162899822, 0.954289282165662, 0.954552872628245, 0.954814943103233, 0.955075502355461, 0.955334559099222, 0.955592121998566, 0.955848199667587, 0.956102800670709, 0.956355933522973, 0.956607606690325, 0.956857828589894, 0.957106607590277, 0.957353952011818, 0.957599870126884, 0.957844370160144, 0.958087460288844, 0.958329148643079, 0.958569443306063, 0.958808352314404, 0.959045883658371, 0.959282045282157, 0.959516845084151, 0.959750290917197, 0.959982390588858, 0.960213151861681, 0.960442582453448, 0.960670690037442, 0.960897482242701, 0.961122966654272, 0.961347150813463, 0.961570042218101, 0.961791648322777, 0.962011976539097, 0.962231034235932, 0.962448828739660, 0.962665367334415, 0.962880657262329, 0.963094705723774, 0.963307519877602, 0.963519106841386, 0.963729473691658, 0.963938627464142, 0.964146575153997, 0.964353323716041, 0.964558880064992, 0.964763251075693, 0.964966443583348, 0.965168464383744, 0.965369320233483, 0.965569017850207, 0.965767563912820, 0.965964965061714, 0.966161227898993, 0.966356358988688, 0.966550364856980, 0.966743251992419, 0.966935026846140, 0.967125695832077, 0.967315265327180, 0.967503741671628, 0.967691131169040, 0.967877440086685, 0.968062674655693, 0.968246841071263, 0.968429945492873, 0.968611994044479, 0.968792992814726, 0.968972947857151, 0.969151865190380, 0.969329750798338, 0.969506610630441, 0.969682450601800, 0.969857276593417, 0.970031094452381, 0.970203909992066, 0.970375728992322, 0.970546557199671, 0.970716400327499, 0.970885264056244, 0.971053154033590, 0.971220075874656, 0.971386035162177, 0.971551037446700, 0.971715088246763, 0.971878193049084, 0.972040357308740, 0.972201586449352, 0.972361885863267, 0.972521260911738, 0.972679716925101, 0.972837259202956, 0.972993893014344, 0.973149623597921, 0.973304456162135, 0.973458395885401, 0.973611447916271, 0.973763617373609, 0.973914909346763, 0.974065328895732, 0.974214881051337, 0.974363570815388, 0.974511403160855, 0.974658383032030, 0.974804515344693, 0.974949804986280, 0.975094256816042, 0.975237875665210, 0.975380666337155, 0.975522633607551, 0.975663782224532, 0.975804116908853, 0.975943642354048, 0.976082363226583, 0.976220284166018, 0.976357409785157, 0.976493744670206, 0.976629293380923, 0.976764060450775, 0.976898050387086, 0.977031267671186, 0.977163716758567, 0.977295402079027, 0.977426328036820, 0.977556499010804, 0.977685919354584, 0.977814593396663, 0.977942525440582, 0.978069719765065, 0.978196180624166, 0.978321912247405, 0.978446918839915, 0.978571204582577, 0.978694773632167, 0.978817630121488, 0.978939778159514, 0.979061221831521, 0.979181965199232, 0.979302012300943, 0.979421367151669, 0.979540033743267, 0.979658016044579, 0.979775318001559, 0.979891943537407, 0.980007896552700, 0.980123180925523, 0.980237800511597, 0.980351759144410, 0.980465060635344, 0.980577708773802, 0.980689707327337, 0.980801060041775, 0.980911770641343, 0.981021842828791, 0.981131280285518, 0.981240086671695, 0.981348265626385, 0.981455820767668, 0.981562755692759, 0.981669073978131, 0.981774779179632, 0.981879874832607, 0.981984364452013, 0.982088251532537, 0.982191539548718, 0.982294231955056, 0.982396332186130, 0.982497843656715, 0.982598769761896, 0.982699113877178, 0.982798879358602, 0.982898069542857, 0.982996687747390, 0.983094737270519, 0.983192221391542, 0.983289143370846, 0.983385506450018, 0.983481313851952, 0.983576568780959, 0.983671274422869, 0.983765433945143, 0.983859050496978, 0.983952127209410, 0.984044667195418, 0.984136673550032, 0.984228149350436, 0.984319097656067, 0.984409521508720, 0.984499423932651, 0.984588807934675, 0.984677676504270, 0.984766032613673, 0.984853879217984, 0.984941219255261, 0.985028055646620, 0.985114391296332, 0.985200229091921, 0.985285571904261, 0.985370422587670, 0.985454783980006, 0.985538658902763, 0.985622050161167, 0.985704960544265, 0.985787392825022, 0.985869349760412, 0.985950834091513, 0.986031848543593, 0.986112395826209, 0.986192478633291, 0.986272099643234, 0.986351261518988, 0.986429966908150, 0.986508218443047, 0.986586018740826, 0.986663370403545, 0.986740276018255, 0.986816738157090, 0.986892759377351, 0.986968342221593, 0.987043489217710, 0.987118202879016, 0.987192485704336, 0.987266340178082, 0.987339768770342, 0.987412773936960, 0.987485358119617, 0.987557523745915, 0.987629273229458, 0.987700608969930, 0.987771533353179, 0.987842048751294, 0.987912157522687, 0.987981862012168, 0.988051164551027, 0.988120067457110, 0.988188573034897, 0.988256683575581, 0.988324401357141, 0.988391728644420, 0.988458667689203, 0.988525220730286, 0.988591389993560, 0.988657177692076, 0.988722586026126, 0.988787617183314, 0.988852273338628, 0.988916556654514, 0.988980469280950, 0.989044013355515, 0.989107191003460, 0.989170004337784, 0.989232455459299, 0.989294546456703, 0.989356279406651, 0.989417656373822, 0.989478679410988, 0.989539350559085, 0.989599671847281, 0.989659645293040, 0.989719272902194, 0.989778556669008, 0.989837498576248, 0.989896100595246, 0.989954364685965, 0.990012292797066, 0.990069886865976, 0.990127148818947, 0.990184080571123, 0.990240684026607, 0.990296961078519, 0.990352913609064, 0.990408543489593, 0.990463852580666, 0.990518842732115, 0.990573515783101, 0.990627873562186, 0.990681917887381, 0.990735650566217, 0.990789073395803, 0.990842188162881, 0.990894996643894, 0.990947500605038, 0.990999701802326, 0.991051601981643, 0.991103202878810, 0.991154506219635, 0.991205513719975, 0.991256227085793, 0.991306648013215, 0.991356778188584, 0.991406619288523, 0.991456172979982, 0.991505440920301, 0.991554424757264, 0.991603126129150, 0.991651546664794, 0.991699687983636, 0.991747551695778, 0.991795139402039, 0.991842452694005, 0.991889493154085, 0.991936262355563, 0.991982761862649, 0.992028993230537, 0.992074958005449, 0.992120657724692, 0.992166093916709, 0.992211268101127, 0.992256181788814, 0.992300836481922, 0.992345233673942, 0.992389374849753, 0.992433261485672, 0.992476895049500, 0.992520277000579, 0.992563408789831, 0.992606291859813, 0.992648927644763, 0.992691317570651, 0.992733463055221, 0.992775365508043, 0.992817026330558, 0.992858446916126, 0.992899628650074, 0.992940572909736, 0.992981281064509, 0.993021754475889, 0.993061994497523, 0.993102002475253, 0.993141779747158, 0.993181327643603, 0.993220647487279, 0.993259740593253, 0.993298608269007, 0.993337251814482, 0.993375672522124, 0.993413871676928, 0.993451850556477, 0.993489610430987, 0.993527152563349, 0.993564478209172, 0.993601588616826, 0.993638485027481, 0.993675168675148, 0.993711640786725, 0.993747902582033, 0.993783955273862, 0.993819800068003, 0.993855438163300, 0.993890870751680, 0.993926099018197, 0.993961124141073, 0.993995947291734, 0.994030569634852, 0.994064992328384, 0.994099216523608, 0.994133243365162, 0.994167073991087, 0.994200709532859, 0.994234151115430, 0.994267399857264, 0.994300456870377, 0.994333323260371, 0.994366000126475, 0.994398488561576, 0.994430789652262, 0.994462904478852, 0.994494834115438, 0.994526579629918, 0.994558142084031, 0.994589522533392, 0.994620722027533, 0.994651741609930, 0.994682582318045, 0.994713245183353, 0.994743731231386, 0.994774041481759, 0.994804176948208, 0.994834138638626, 0.994863927555089, 0.994893544693898, 0.994922991045609, 0.994952267595065, 0.994981375321428, 0.995010315198218, 0.995039088193338, 0.995067695269109, 0.995096137382307, 0.995124415484185, 0.995152530520516, 0.995180483431615, 0.995208275152377, 0.995235906612305, 0.995263378735543, 0.995290692440906, 0.995317848641908, 0.995344848246799, 0.995371692158589, 0.995398381275081, 0.995424916488902, 0.995451298687532, 0.995477528753331, 0.995503607563572, 0.995529535990471, 0.995555314901212, 0.995580945157980, 0.995606427617986, 0.995631763133501, 0.995656952551878, 0.995681996715587, 0.995706896462238, 0.995731652624611, 0.995756266030684, 0.995780737503661, 0.995805067861999, 0.995829257919434, 0.995853308485011, 0.995877220363109, 0.995900994353468, 0.995924631251219, 0.995948131846904, 0.995971496926509, 0.995994727271487, 0.996017823658784, 0.996040786860867, 0.996063617645748, 0.996086316777010, 0.996108885013833, 0.996131323111020, 0.996153631819019, 0.996175811883953, 0.996197864047641, 0.996219789047626, 0.996241587617197, 0.996263260485414, 0.996284808377133, 0.996306232013030, 0.996327532109627, 0.996348709379313, 0.996369764530367, 0.996390698266986, 0.996411511289307, 0.996432204293427, 0.996452777971432, 0.996473233011415, 0.996493570097501, 0.996513789909870, 0.996533893124782, 0.996553880414595, 0.996573752447791, 0.996593509888996, 0.996613153399004, 0.996632683634800, 0.996652101249579, 0.996671406892768, 0.996690601210052, 0.996709684843392, 0.996728658431045, 0.996747522607589, 0.996766278003944, 0.996784925247389, 0.996803464961589, 0.996821897766609, 0.996840224278942, 0.996858445111523, 0.996876560873754, 0.996894572171523, 0.996912479607225, 0.996930283779778, 0.996947985284650, 0.996965584713873, 0.996983082656066, 0.997000479696453, 0.997017776416885, 0.997034973395856, 0.997052071208524, 0.997069070426732, 0.997085971619024, 0.997102775350666, 0.997119482183665, 0.997136092676786, 0.997152607385572, 0.997169026862364, 0.997185351656317, 0.997201582313418, 0.997217719376507, 0.997233763385295, 0.997249714876377, 0.997265574383257, 0.997281342436361, 0.997297019563058, 0.997312606287674, 0.997328103131512, 0.997343510612869, 0.997358829247053, 0.997374059546402, 0.997389202020298, 0.997404257175186, 0.997419225514590, 0.997434107539133, 0.997448903746546, 0.997463614631697, 0.997478240686593, 0.997492782400410, 0.997507240259498, 0.997521614747407, 0.997535906344895, 0.997550115529951, 0.997564242777804, 0.997578288560945, 0.997592253349141, 0.997606137609448, 0.997619941806230, 0.997633666401173, 0.997647311853300, 0.997660878618989, 0.997674367151984, 0.997687777903414, 0.997701111321806, 0.997714367853099, 0.997727547940665, 0.997740652025314, 0.997753680545318, 0.997766633936419, 0.997779512631849, 0.997792317062339, 0.997805047656137, 0.997817704839023, 0.997830289034321, 0.997842800662913, 0.997855240143254, 0.997867607891388, 0.997879904320957, 0.997892129843220, 0.997904284867063, 0.997916369799016, 0.997928385043263, 0.997940331001657, 0.997952208073736, 0.997964016656731, 0.997975757145586, 0.997987429932964, 0.997999035409265, 0.998010573962640, 0.998022045978998, 0.998033451842025, 0.998044791933193, 0.998056066631777, 0.998067276314861, 0.998078421357358, 0.998089502132018, 0.998100519009440, 0.998111472358087, 0.998122362544298, 0.998133189932299, 0.998143954884216, 0.998154657760085, 0.998165298917869, 0.998175878713463, 0.998186397500714, 0.998196855631425, 0.998207253455372, 0.998217591320314, 0.998227869572003, 0.998238088554200, 0.998248248608682, 0.998258350075256, 0.998268393291767, 0.998278378594115, 0.998288306316262, 0.998298176790243, 0.998307990346180, 0.998317747312291, 0.998327448014900, 0.998337092778451, 0.998346681925516, 0.998356215776808, 0.998365694651188, 0.998375118865682, 0.998384488735485, 0.998393804573975, 0.998403066692725, 0.998412275401508, 0.998421431008313, 0.998430533819352, 0.998439584139072, 0.998448582270164, 0.998457528513573, 0.998466423168510, 0.998475266532458, 0.998484058901188, 0.998492800568763, 0.998501491827551, 0.998510132968233, 0.998518724279817, 0.998527266049641, 0.998535758563387, 0.998544202105091, 0.998552596957149, 0.998560943400330, 0.998569241713784, 0.998577492175050, 0.998585695060069, 0.998593850643187, 0.998601959197172, 0.998610020993217, 0.998618036300951, 0.998626005388448, 0.998633928522238, 0.998641805967313, 0.998649637987135, 0.998657424843651, 0.998665166797293, 0.998672864106994, 0.998680517030192, 0.998688125822844, 0.998695690739426, 0.998703212032951, 0.998710689954971, 0.998718124755586, 0.998725516683457, 0.998732865985809, 0.998740172908442, 0.998747437695738, 0.998754660590670, 0.998761841834811, 0.998768981668340, 0.998776080330051, 0.998783138057361, 0.998790155086317, 0.998797131651608, 0.998804067986566, 0.998810964323179, 0.998817820892098, 0.998824637922643, 0.998831415642812, 0.998838154279288, 0.998844854057447, 0.998851515201364, 0.998858137933826, 0.998864722476330, 0.998871269049099, 0.998877777871085, 0.998884249159979, 0.998890683132214, 0.998897080002977, 0.998903439986213, 0.998909763294634, 0.998916050139726, 0.998922300731753, 0.998928515279770, 0.998934693991623, 0.998940837073961, 0.998946944732243, 0.998953017170741, 0.998959054592549, 0.998965057199591, 0.998971025192627, 0.998976958771257, 0.998982858133933, 0.998988723477960, 0.998994554999507, 0.999000352893612, 0.999006117354185, 0.999011848574023, 0.999017546744807, 0.999023212057114, 0.999028844700424, 0.999034444863121, 0.999040012732505, 0.999045548494794, 0.999051052335136, 0.999056524437606, 0.999061964985223, 0.999067374159945, 0.999072752142686, 0.999078099113313, 0.999083415250658, 0.999088700732521, 0.999093955735676, 0.999099180435879, 0.999104375007872, 0.999109539625389, 0.999114674461161, 0.999119779686926, 0.999124855473430, 0.999129901990433, 0.999134919406719, 0.999139907890096, 0.999144867607405, 0.999149798724527, 0.999154701406385, 0.999159575816949, 0.999164422119247, 0.999169240475363, 0.999174031046451, 0.999178793992732, 0.999183529473505, 0.999188237647149, 0.999192918671131, 0.999197572702009, 0.999202199895438, 0.999206800406177, 0.999211374388092, 0.999215921994160, 0.999220443376479, 0.999224938686266, 0.999229408073870, 0.999233851688770, 0.999238269679584, 0.999242662194074, 0.999247029379149, 0.999251371380871, 0.999255688344459, 0.999259980414296, 0.999264247733931, 0.999268490446087, 0.999272708692662, 0.999276902614737, 0.999281072352579, 0.999285218045647, 0.999289339832594, 0.999293437851275, 0.999297512238749, 0.999301563131286, 0.999305590664370, 0.999309594972702, 0.999313576190208, 0.999317534450041, 0.999321469884586, 0.999325382625466, 0.999329272803543, 0.999333140548925, 0.999336985990971, 0.999340809258293, 0.999344610478760, 0.999348389779507, 0.999352147286933, 0.999355883126709, 0.999359597423781, 0.999363290302376, 0.999366961886004, 0.999370612297460, 0.999374241658836, 0.999377850091515, 0.999381437716183, 0.999385004652830, 0.999388551020752, 0.999392076938559, 0.999395582524178, 0.999399067894852, 0.999402533167152, 0.999405978456975, 0.999409403879549, 0.999412809549440, 0.999416195580550, 0.999419562086127, 0.999422909178765, 0.999426236970408, 0.999429545572355, 0.999432835095264, 0.999436105649153, 0.999439357343409, 0.999442590286784, 0.999445804587405, 0.999449000352776, 0.999452177689781, 0.999455336704686, 0.999458477503145, 0.999461600190204, 0.999464704870302, 0.999467791647277, 0.999470860624365, 0.999473911904211, 0.999476945588866, 0.999479961779791, 0.999482960577865, 0.999485942083383, 0.999488906396063, 0.999491853615047, 0.999494783838906, 0.999497697165643, 0.999500593692693, 0.999503473516933, 0.999506336734680, 0.999509183441694, 0.999512013733186, 0.999514827703813, 0.999517625447692, 0.999520407058393, 0.999523172628949, 0.999525922251854, 0.999528656019071, 0.999531374022032, 0.999534076351640, 0.999536763098277, 0.999539434351802, 0.999542090201555, 0.999544730736362, 0.999547356044537, 0.999549966213885, 0.999552561331702, 0.999555141484784, 0.999557706759425, 0.999560257241421, 0.999562793016074, 0.999565314168194, 0.999567820782101, 0.999570312941631, 0.999572790730134, 0.999575254230480, 0.999577703525063, 0.999580138695799, 0.999582559824134, 0.999584966991044, 0.999587360277036, 0.999589739762155, 0.999592105525984, 0.999594457647647, 0.999596796205810, 0.999599121278688, 0.999601432944044, 0.999603731279192, 0.999606016361000, 0.999608288265895, 0.999610547069860, 0.999612792848442, 0.999615025676751, 0.999617245629467, 0.999619452780835, 0.999621647204674, 0.999623828974379, 0.999625998162917, 0.999628154842840, 0.999630299086278, 0.999632430964946, 0.999634550550144, 0.999636657912765, 0.999638753123288, 0.999640836251789, 0.999642907367938, 0.999644966541006, 0.999647013839861, 0.999649049332977, 0.999651073088431, 0.999653085173908, 0.999655085656703, 0.999657074603723, 0.999659052081489, 0.999661018156138, 0.999662972893426, 0.999664916358731, 0.999666848617051, 0.999668769733013, 0.999670679770868, 0.999672578794498, 0.999674466867417, 0.999676344052772, 0.999678210413346, 0.999680066011560, 0.999681910909475, 0.999683745168795, 0.999685568850866, 0.999687382016683, 0.999689184726888, 0.999690977041772, 0.999692759021280, 0.999694530725011, 0.999696292212221, 0.999698043541823, 0.999699784772390, 0.999701515962159, 0.999703237169030, 0.999704948450569, 0.999706649864011, 0.999708341466260, 0.999710023313892, 0.999711695463157, 0.999713357969981, 0.999715010889967, 0.999716654278397, 0.999718288190235, 0.999719912680127, 0.999721527802406, 0.999723133611090, 0.999724730159885, 0.999726317502188, 0.999727895691089, 0.999729464779371, 0.999731024819512, 0.999732575863689, 0.999734117963777, 0.999735651171351, 0.999737175537690, 0.999738691113778, 0.999740197950303, 0.999741696097663, 0.999743185605962, 0.999744666525018, 0.999746138904361, 0.999747602793235, 0.999749058240600, 0.999750505295135, 0.999751944005236, 0.999753374419022, 0.999754796584333, 0.999756210548734, 0.999757616359516, 0.999759014063696, 0.999760403708021, 0.999761785338968, 0.999763159002747, 0.999764524745300, 0.999765882612304, 0.999767232649175, 0.999768574901063, 0.999769909412863, 0.999771236229206, 0.999772555394468, 0.999773866952770, 0.999775170947977, 0.999776467423701, 0.999777756423304, 0.999779037989896, 0.999780312166340, 0.999781578995252, 0.999782838519000, 0.999784090779710, 0.999785335819264, 0.999786573679304, 0.999787804401229, 0.999789028026201, 0.999790244595146, 0.999791454148751, 0.999792656727470, 0.999793852371525, 0.999795041120904, 0.999796223015365, 0.999797398094437, 0.999798566397420, 0.999799727963389, 0.999800882831194, 0.999802031039458, 0.999803172626585, 0.999804307630755, 0.999805436089928, 0.999806558041846, 0.999807673524034, 0.999808782573798, 0.999809885228232, 0.999810981524215, 0.999812071498411, 0.999813155187276, 0.999814232627054, 0.999815303853780, 0.999816368903282, 0.999817427811181, 0.999818480612892, 0.999819527343627, 0.999820568038394, 0.999821602731999, 0.999822631459048, 0.999823654253947, 0.999824671150904, 0.999825682183930, 0.999826687386837, 0.999827686793247, 0.999828680436584, 0.999829668350081, 0.999830650566780, 0.999831627119530, 0.999832598040993, 0.999833563363642, 0.999834523119762, 0.999835477341453, 0.999836426060628, 0.999837369309019, 0.999838307118172, 0.999839239519453, 0.999840166544046, 0.999841088222956, 0.999842004587008, 0.999842915666851, 0.999843821492957, 0.999844722095620, 0.999845617504962, 0.999846507750930, 0.999847392863299, 0.999848272871671, 0.999849147805479, 0.999850017693984, 0.999850882566282, 0.999851742451297, 0.999852597377790, 0.999853447374352, 0.999854292469414, 0.999855132691238, 0.999855968067927, 0.999856798627420, 0.999857624397495, 0.999858445405771, 0.999859261679706, 0.999860073246602, 0.999860880133600, 0.999861682367688, 0.999862479975697, 0.999863272984303, 0.999864061420028, 0.999864845309242, 0.999865624678163, 0.999866399552856, 0.999867169959238, 0.999867935923074, 0.999868697469984, 0.999869454625437, 0.999870207414756, 0.999870955863119, 0.999871699995558, 0.999872439836961, 0.999873175412071, 0.999873906745491, 0.999874633861680, 0.999875356784956, 0.999876075539499, 0.999876790149347, 0.999877500638400, 0.999878207030422, 0.999878909349037, 0.999879607617735, 0.999880301859869, 0.999880992098660, 0.999881678357191, 0.999882360658416, 0.999883039025154, 0.999883713480093, 0.999884384045790, 0.999885050744674, 0.999885713599041, 0.999886372631062, 0.999887027862777, 0.999887679316102, 0.999888327012824, 0.999888970974606, 0.999889611222985, 0.999890247779374, 0.999890880665064, 0.999891509901222, 0.999892135508892, 0.999892757508998, 0.999893375922343, 0.999893990769611, 0.999894602071364, 0.999895209848049, 0.999895814119992, 0.999896414907404, 0.999897012230377, 0.999897606108891, 0.999898196562807, 0.999898783611872, 0.999899367275722, 0.999899947573877, 0.999900524525746, 0.999901098150624, 0.999901668467696, 0.999902235496038, 0.999902799254614, 0.999903359762278, 0.999903917037777, 0.999904471099749, 0.999905021966726, 0.999905569657131, 0.999906114189281, 0.999906655581389, 0.999907193851562, 0.999907729017802, 0.999908261098009, 0.999908790109978, 0.999909316071401, 0.999909838999870, 0.999910358912875, 0.999910875827803, 0.999911389761944, 0.999911900732486, 0.999912408756519, 0.999912913851033, 0.999913416032922, 0.999913915318981, 0.999914411725910, 0.999914905270310, 0.999915395968689, 0.999915883837457, 0.999916368892933, 0.999916851151338, 0.999917330628803, 0.999917807341362, 0.999918281304961, 0.999918752535451, 0.999919221048593, 0.999919686860055, 0.999920149985418, 0.999920610440170, 0.999921068239712, 0.999921523399355, 0.999921975934323, 0.999922425859749, 0.999922873190682, 0.999923317942083, 0.999923760128828, 0.999924199765704, 0.999924636867417, 0.999925071448584, 0.999925503523741, 0.999925933107339, 0.999926360213745, 0.999926784857243, 0.999927207052037, 0.999927626812246, 0.999928044151910, 0.999928459084987, 0.999928871625353, 0.999929281786808, 0.999929689583068, 0.999930095027774, 0.999930498134484, 0.999930898916681, 0.999931297387769, 0.999931693561076, 0.999932087449851, 0.999932479067268, 0.999932868426425, 0.999933255540344, 0.999933640421972, 0.999934023084183, 0.999934403539773, 0.999934781801468, 0.999935157881918, 0.999935531793703, 0.999935903549326, 0.999936273161223, 0.999936640641754, 0.999937006003210, 0.999937369257811, 0.999937730417706, 0.999938089494975, 0.999938446501625, 0.999938801449599, 0.999939154350766, 0.999939505216931, 0.999939854059827, 0.999940200891122, 0.999940545722417, 0.999940888565243, 0.999941229431067, 0.999941568331290, 0.999941905277247, 0.999942240280206, 0.999942573351372, 0.999942904501885, 0.999943233742820, 0.999943561085189, 0.999943886539939, 0.999944210117956, 0.999944531830061, 0.999944851687015, 0.999945169699516, 0.999945485878199, 0.999945800233638, 0.999946112776349, 0.999946423516784, 0.999946732465335, 0.999947039632335, 0.999947345028059, 0.999947648662719, 0.999947950546472, 0.999948250689413, 0.999948549101582, 0.999948845792958, 0.999949140773464, 0.999949434052967, 0.999949725641274, 0.999950015548139, 0.999950303783258, 0.999950590356270, 0.999950875276759, 0.999951158554257, 0.999951440198235, 0.999951720218115, 0.999951998623262, 0.999952275422986, 0.999952550626547, 0.999952824243147, 0.999953096281938, 0.999953366752019, 0.999953635662435, 0.999953903022180, 0.999954168840197, 0.999954433125375, 0.999954695886554, 0.999954957132522, 0.999955216872016, 0.999955475113724, 0.999955731866281, 0.999955987138277, 0.999956240938247, 0.999956493274681, 0.999956744156019, 0.999956993590650, 0.999957241586917, 0.999957488153115, 0.999957733297490, 0.999957977028242, 0.999958219353520, 0.999958460281432, 0.999958699820033, 0.999958937977337, 0.999959174761307, 0.999959410179863, 0.999959644240880, 0.999959876952185, 0.999960108321561, 0.999960338356746, 0.999960567065435, 0.999960794455276, 0.999961020533874, 0.999961245308792, 0.999961468787545, 0.999961690977610, 0.999961911886416, 0.999962131521353, 0.999962349889766, 0.999962566998959, 0.999962782856192, 0.999962997468686, 0.999963210843617, 0.999963422988123, 0.999963633909299, 0.999963843614198, 0.999964052109835, 0.999964259403183, 0.999964465501175, 0.999964670410704, 0.999964874138623, 0.999965076691746, 0.999965278076847, 0.999965478300662, 0.999965677369887, 0.999965875291180, 0.999966072071161, 0.999966267716411, 0.999966462233474, 0.999966655628854, 0.999966847909022, 0.999967039080406, 0.999967229149402, 0.999967418122365, 0.999967606005617, 0.999967792805441, 0.999967978528085, 0.999968163179759, 0.999968346766641, 0.999968529294870, 0.999968710770551, 0.999968891199752, 0.999969070588510, 0.999969248942823, 0.999969426268657, 0.999969602571942, 0.999969777858575, 0.999969952134419, 0.999970125405302, 0.999970297677018, 0.999970468955331, 0.999970639245968, 0.999970808554625, 0.999970976886965, 0.999971144248616, 0.999971310645178, 0.999971476082214, 0.999971640565259, 0.999971804099813, 0.999971966691345, 0.999972128345294, 0.999972289067067, 0.999972448862038, 0.999972607735552, 0.999972765692922, 0.999972922739432, 0.999973078880334, 0.999973234120851, 0.999973388466173, 0.999973541921464, 0.999973694491856, 0.999973846182451, 0.999973996998323, 0.999974146944516, 0.999974296026045, 0.999974444247896, 0.999974591615026, 0.999974738132365, 0.999974883804812, 0.999975028637239, 0.999975172634491, 0.999975315801383, 0.999975458142704, 0.999975599663215, 0.999975740367648, 0.999975880260709, 0.999976019347078, 0.999976157631406, 0.999976295118318, 0.999976431812413, 0.999976567718261, 0.999976702840409, 0.999976837183376, 0.999976970751654, 0.999977103549712, 0.999977235581990, 0.999977366852905, 0.999977497366847, 0.999977627128180, 0.999977756141246, 0.999977884410358, 0.999978011939807, 0.999978138733858, 0.999978264796751, 0.999978390132704, 0.999978514745907, 0.999978638640529, 0.999978761820713, 0.999978884290579, 0.999979006054223, 0.999979127115717, 0.999979247479111, 0.999979367148430, 0.999979486127677, 0.999979604420830, 0.999979722031846, 0.999979838964659, 0.999979955223179, 0.999980070811295, 0.999980185732873, 0.999980299991755, 0.999980413591765, 0.999980526536701, 0.999980638830340, 0.999980750476438, 0.999980861478730, 0.999980971840927, 0.999981081566722, 0.999981190659782, 0.999981299123759, 0.999981406962278, 0.999981514178947, 0.999981620777352, 0.999981726761057, 0.999981832133608, 0.999981936898528, 0.999982041059322, 0.999982144619473, 0.999982247582445, 0.999982349951682, 0.999982451730607, 0.999982552922624, 0.999982653531117, 0.999982753559453, 0.999982853010975, 0.999982951889011, 0.999983050196867, 0.999983147937831, 0.999983245115172, 0.999983341732140, 0.999983437791968, 0.999983533297866, 0.999983628253031, 0.999983722660636, 0.999983816523841, 0.999983909845784, 0.999984002629586, 0.999984094878351, 0.999984186595164, 0.999984277783093, 0.999984368445186, 0.999984458584477, 0.999984548203981, 0.999984637306693, 0.999984725895596, 0.999984813973650 };



	double findT(double p, double * aP, size_t NaP, double dx)
	{
		double * pP = std::upper_bound(aP, aP + NaP, p);

		if (pP == aP + NaP)
			return 1.0;
		else if (pP == aP)
			return 0.0;
		else
		{
			double y2 = *pP;
			double y1 = *(pP - 1);
			double x = (double)(pP - aP) + (p - y1) / (y2 - y1);
			x = x *dx;
			return x;
		}
	}
	double findT(double p, DimensionType d)
	{
		if (d == 2)
			return findT(p, aP2, 2000, 0.001);
		else if (d == 3)
			return findT(p, aP3, 2000, 0.001);
		else
		{
			std::cout << "Error in PairStatisticsCLI.cpp : findT() : unsupported dimension!\n";
			return 0.0;
		}
	}
};

namespace
{
	//find a radius a that produces the desired Ev
	//must already have Ev computed
	double InterpolateEv(std::string EvPrefix, double DesiredEv)
	{
		std::vector< std::vector<GeometryVector> > Evs;
		ReadGraceData(Evs, EvPrefix);
		std::vector<GeometryVector> & Ev = Evs[0];
		std::vector<GeometryVector> result;

		auto InterpolateEvFunc = [&Ev](double wantedEv) ->double
		{
			auto iter = std::lower_bound(Ev.begin(), Ev.end(), wantedEv, [](const GeometryVector & v, const double & x) -> bool
			{
				return v.x[1] > x;
			});
			if (iter >= Ev.end() - 1 || iter == Ev.begin())
				return 0.0;
			iter--;
			return iter->x[0] + ((iter + 1)->x[0] - iter->x[0]) / ((iter + 1)->x[1] - iter->x[1])*(wantedEv - iter->x[1]);
		};
		double a = InterpolateEvFunc(DesiredEv);
		return a;
	}


	//helper classes for int PairStatisticsCLI(), two types of helper classes are needed

	//helper type 1 : callable types to get configurations
	class PrefixNumberSuffix
	{
	public:
		std::string path;
		std::string PostName;
		double Rescale;
		Configuration (*GetFunction)(std::istream & ifile);
		PrefixNumberSuffix(std::istream & ifile, std::ostream & ofile, double Rescale)
		{
			char tempstring[1000];
			this->Rescale=Rescale;
			ofile<<"Input Prefix:";
			ifile>>this->path;
			ofile<<"Input Suffix:";
			ifile>>this->PostName;

inputtype:
			ofile<<"Input File type:";
			ifile>>tempstring;
			if(strcmp(tempstring, "Pos")==0)
				this->GetFunction=ReadPos;
			else if(strcmp(tempstring, "Xml")==0)
				this->GetFunction=ReadHoomdXml;
			else if(strcmp(tempstring, "Stealth")==0)
				this->GetFunction=ReadStealthOutput;
			else if(strcmp(tempstring, "Coordinate")==0)
				this->GetFunction=ReadCoordinate;
			else
			{
				std::cout<<"Unrecognized file type!\n";
				goto inputtype;
			}
		}
		Configuration operator() (size_t i)const
		{
			std::stringstream name;
			name<<path;
			name<<i;
			name<<PostName;
			std::string filename;
			name>>filename;
			std::fstream ifile(filename.c_str(), std::fstream::in);
			Configuration result=GetFunction(ifile);
			result.Rescale(Rescale);
			return result;
		}
	};

	class readTfEnsembleCCOutput
	{
	public:
		double L;
		DimensionType dim;
		int nFolder, nc;
		readTfEnsembleCCOutput(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "input nFolder, Nc, dimension, L";
			ifile >> nFolder >> nc >> dim >> L;
		}
		Configuration operator() (size_t i)
		{
			int iFolder = i / nc;
			int iNc = i%nc;

			if (iFolder >= nFolder)
			{
				std::cerr << "error in readTfEnsembleCCOutput : folder index greater than number of folders\n";
				return Configuration();
			}
			std::stringstream ss;
			ss << iFolder << "/" << iNc << ".txt";
			std::fstream ifile(ss.str(), std::fstream::in);
			return ReadCartesianCoordinate(ifile, L, dim);
		}
	};
	class ReadConfigPack
	{
	public:
		double Rescale;
		ConfigurationPack p;
		ReadConfigPack(std::istream & ifile, std::ostream & ofile, double Rescale)
		{
			this->Rescale = Rescale;
			ofile << "Input Prefix:";
			std::string prefix;
			ifile >> prefix;
			p.Open(prefix);
		}
		Configuration operator() (size_t i)
		{
			Configuration result = p.GetConfig(i);
			result.Rescale(Rescale);
			return result;
		}
	};
	class SampleConfigPack
	{
	public:
		double Rescale;
		ConfigurationPack p;
		size_t n;
		SampleConfigPack(std::istream & ifile, std::ostream & ofile, double Rescale)
		{
			this->Rescale = Rescale;
			ofile << "Input Prefix:";
			std::string prefix;
			ifile >> prefix;
			p.Open(prefix);
			ofile << "Sample 1 configuration from every n configurations, n=";
			ifile >> n;
		}
		Configuration operator() (size_t i)
		{
			Configuration result = p.GetConfig(i*n);
			result.Rescale(Rescale);
			return result;
		}
	};

	//take every configuration from GetConfigsFunction, then rescale it to unit number density, then output
	class RescaleToUnitDensity
	{
	public:
		std::function<const Configuration(size_t i)> GetConfigsFunction;
		RescaleToUnitDensity(std::function<const Configuration(size_t i)> GetConfigsFunction) : GetConfigsFunction(GetConfigsFunction)
		{}
		Configuration operator() (size_t i)
		{
			Configuration result = GetConfigsFunction(i);
			result.Resize(result.NumParticle());
			return result;
		}
	};

	class ReadConfigPack_withInitialNumber
	{
	public:
		double Rescale;
		ConfigurationPack p;
		size_t InitialNumber;
		ReadConfigPack_withInitialNumber(std::istream & ifile, std::ostream & ofile, double Rescale)
		{
			this->Rescale=Rescale;
			ofile<<"Input Prefix:";
			std::string prefix;
			ifile>>prefix;
			p.Open(prefix);
			ofile<<"Input Initial Number:";
			ifile>>InitialNumber;
		}
		Configuration operator() (size_t i)
		{
			Configuration result=p.GetConfig(i+InitialNumber);
			result.Rescale(Rescale);
			return result;
		}
	};
	class SingleConfiguration
	{
	public:
		Configuration c;
		SingleConfiguration( Configuration C ) : c(C)
		{
		}
		Configuration operator() (size_t i)
		{
			assert(i==0);
			return this->c;
		}
	};

	//helper type 2 : callable types to perform calculations
	class Computation
	{
	public:
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig) =0;
		virtual void Write(const std::string OutputPrefix) =0;
		virtual void Plot(const std::string OutputPrefix, const std::string & Title) =0;

		//some computations allow manipulating resolution preference
		//default=1, set>1 to get better x resolution, <1 to get better y resolution
		//virtual void SetResolutionPreference(double Preference)
		//{
		//	std::cerr<<"Warning : SetResolutionPreference not supported by this calculation!\n";
		//}

		//some computations allow additional options
		//any command not understood by PairStatisticsCLI() is passed to here
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			//by default, accept no additional option.
			output << "Unrecognized command!\n";
		}

		virtual ~Computation()
		{
		}
	};
	class g2Computation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double g2rmax;
		double resolution;
		HistogramGenerator * pHGen;
		g2Computation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"g2 R_max=";
			ifile>>g2rmax;
			resolution=1.0;
			pHGen = nullptr;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			if (this->pHGen == nullptr)
				::IsotropicTwoPairCorrelation(GetConfigsFunction, NumConfig, g2rmax, result, 5000000, resolution);
			else
				::IsotropicTwoPairCorrelation(GetConfigsFunction, NumConfig, g2rmax, result, *this->pHGen);

			Configuration c = GetConfigsFunction(0);
			double tau = TauFromG2(result, c.GetDimension());
			std::cout << "tau from g2=" << tau << '\n';
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"g_2:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_gofr"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix+std::string("_PairCorrelation"), "r", "g_2(r)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_gofr"), "r", "g\\s2\\N(r)", Title);
		}

		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "ResolutionPreference")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> resolution;
			else if (option == "ManualBins")
			{
				output << "Input min, increment, and max of bins:";
				double min, inc, max;
				input >> min >> inc >> max;

				if (this->pHGen != nullptr)
					delete this->pHGen;
				this->pHGen = new HistogramGenerator;
				for (double x = min; x < max; x += inc)
					this->pHGen->bins.push_back(HistogramGenerator::bin(0, x));
			}
			else
				output << "Unrecognized command!\n";
		}
		virtual ~g2Computation()
		{
			if (pHGen != nullptr)
				delete pHGen;
		}
	};
	class Directionalg2Computation : public Computation
	{
	public:
		double g2rmax;
		size_t NumThetaBins;
		std::vector< std::vector<GeometryVector> > results;
		Directionalg2Computation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"g2 R_max=";
			ifile>>g2rmax;
			ofile<<"Num Theta Bins=";
			ifile>>NumThetaBins;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			results.clear();
			//::IsotropicTwoPairCorrelation(GetConfigsFunction, NumConfig, g2rmax, result, 50000000, 1.0);
			TwoPairCorrelation_2DAnisotropic(GetConfigsFunction, NumConfig, g2rmax, results, NumThetaBins);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::fstream xout( (OutputPrefix+std::string("_x.txt")).c_str(), std::fstream::out);
			std::fstream yout( (OutputPrefix+std::string("_y.txt")).c_str(), std::fstream::out);
			std::fstream g2out( (OutputPrefix+std::string("_g2.txt")).c_str(), std::fstream::out);

			for(auto iter=results.begin(); iter!=results.end(); iter++)
			{
				for(auto iter2=iter->begin(); iter2!=iter->end(); iter2++)
				{
					double x=iter2->x[0]*std::cos(iter2->x[1]);
					double y=iter2->x[0]*std::sin(iter2->x[1]);
					xout<<x<<" \t";
					yout<<y<<" \t";
					g2out<<iter2->x[2]<<" \t";
				}
				xout<<'\n';
				yout<<'\n';
				g2out<<'\n';
			}
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::cerr<<"Directionalg2Computation::Plot is not implemented!\n";
		}
	};
	class SkComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double CircularKMax, LinearKMax, KPrecision;
		double SampleProbability;
		SkComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"circular K_max=";
			ifile>>CircularKMax;
			ofile<<"linear K_max=";
			ifile>>LinearKMax;
			ofile<<"K precision (binning width)=";
			ifile>>KPrecision;

			SampleProbability = 1.0;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::IsotropicStructureFactor(GetConfigsFunction, NumConfig, CircularKMax, LinearKMax, result, KPrecision, SampleProbability);
			Configuration c = GetConfigsFunction(0);
			double tau = TauFromSk(result, c.GetDimension(), c.NumParticle()/c.PeriodicVolume() );
			std::cout << "tau from Sk=" << tau << '\n';
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"S(k):\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_Sofk"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix+std::string("_StructureFactor"), "k", "S(k)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_Sofk"), "k", "S(k)", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "SampleProbability")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> SampleProbability;
			else
				output << "Unrecognized command!\n";
		}
	};
	class HpComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		HpComputation(std::istream & ifile, std::ostream & ofile)
		{
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::NearestNeighborDistrubution(GetConfigsFunction, NumConfig, result, 50000000, 1.0);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Hp(r):\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_Hp"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix+std::string("_Hp"), "r", "H_p(r)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_Hp"), "r", "H\\sp\\N(r)", Title);
		}
	};
	class HvComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		std::vector<GeometryVector> ev;
		std::vector<GeometryVector> gv;
		double resolutionPreference, oversampling;
		size_t samplesBeforeBinning;
		HvComputation(std::istream & ifile, std::ostream & ofile)
		{
			samplesBeforeBinning = 500000;
			resolutionPreference = 1.0;
			oversampling = 1.0;
		}
		double searchEvFunction(double r)
		{
			auto compareFunc = [](const GeometryVector & l, double r) -> bool
			{
				return l.x[0] < r;
			};
			auto iter = std::lower_bound(ev.begin(), ev.end(), r, compareFunc);
			if (iter == ev.begin()) return 1.0;
			else if (iter == ev.end()) return 0.0;
			return iter[-1].x[1] + (iter->x[1] - iter[-1].x[1]) / (iter->x[0] - iter[-1].x[0])*(r - iter[-1].x[0]);
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::HvDistrubution(GetConfigsFunction, NumConfig, result, samplesBeforeBinning, resolutionPreference, oversampling);

			//find Ev and its moments
			double sum = 0.0, moment0 = 0.0, moment1 = 0.0;
			ev.push_back(GeometryVector(0.0, 1.0));
			for (auto iter = result.begin(); iter != result.end() - 1; ++iter)
			{
				double dx = 2 * iter->x[2];
				double y = iter->x[1];
				sum += dx*y;
				double xend = iter->x[0] + iter->x[2];
				if (iter->x[0] > 0)
				{
					ev.push_back(GeometryVector(xend, 1.0 - sum));
					moment0 += (1.0 - sum)*dx;
					moment1 += xend*(1.0 - sum)*dx;
				}
			}

			double rho = 0.0;
			for (int i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				rho += c.NumParticle() / c.PeriodicVolume();
			}
			rho /= NumConfig;
			Configuration c = GetConfigsFunction(0);
			DimensionType dim = c.GetDimension();

			for (auto iter = result.begin(); iter != result.end(); ++iter)
			{
				double r = iter->x[0];
				double h = iter->x[1];
				double e = searchEvFunction(r);
				double g = h / HyperSphere_SurfaceArea(dim, r) / e / rho;
				if(g==g && r>0)
					gv.push_back(GeometryVector(r, g));
			}
			//the last bin is too inaccurate
			gv.pop_back();

			//finally, remove the r<0 part of Hv
			std::vector<GeometryVector> temp;
			temp.push_back(GeometryVector(0.0, 0.0));
			for (auto iter = result.begin(); iter != result.end(); ++iter)
				if (iter->x[0] > 0.0)
					temp.push_back(*iter);
			std::swap(temp, result);

			std::cout << "Quantizer error G=" << moment1 * 2 / dim * std::pow(rho, 2.0/dim) << '\n';
			std::cout << "0th moment of Ev=" << moment0 << '\n';
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Hv(r):\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_Hv"));
			WriteFunction(ev, OutputPrefix+std::string("_Ev"));
			WriteFunction(gv, OutputPrefix+std::string("_Gv"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix+std::string("_Hv"), "r", "H_v(r)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_Hv"), "r", "H\\sv\\N(r)", Title);
			PlotFunction_Grace(ev, OutputPrefix+std::string("_Ev"), "r", "E\\sv\\N(r)", Title);
			PlotFunction_Grace(gv, OutputPrefix+std::string("_Gv"), "r", "G\\sv\\N(r)", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "ResolutionPreference")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> resolutionPreference;
			else if (option == "SamplesBeforeBinning")
				input >> samplesBeforeBinning;
			else if (option == "Oversampling")
				input >> oversampling;
			else
				output << "Unrecognized command!\n";
		}
	};
	class VoronoiVolumeComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		VoronoiVolumeComputation(std::istream & ifile, std::ostream & ofile)
		{
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::VoronoiVolumeDistrubution(GetConfigsFunction, NumConfig, result);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Voronoi cell volume PDF:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_VoronoiVolumeDistribution"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix+std::string("_VoronoiVolumeDistribution"), "V", "p(V)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_VoronoiVolumeDistribution"), "V", "p(V)", Title);
		}
	};
	class VoronoiNumSidesComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		VoronoiNumSidesComputation(std::istream & ifile, std::ostream & ofile)
		{
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::VoronoiNumSidesDistrubution(GetConfigsFunction, NumConfig, result);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "Voronoi cell number of sides distribution:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix + std::string("_VoronoiNumSidesDistribution"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix + std::string("_VoronoiNumSidesDistribution"), "n", "P(n)");
			PlotFunction_Grace(result, OutputPrefix + std::string("_VoronoiNumSidesDistribution"), "n", "P(n)", Title);
		}
	};
	class CoveringRadiusDistributionComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		CoveringRadiusDistributionComputation(std::istream & ifile, std::ostream & ofile)
		{
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			std::vector<double> radii;
			radii.resize(NumConfig, 0.0);
			progress_display pd(NumConfig);
#pragma omp parallel for schedule(guided)
			for (int i = 0; i<NumConfig; i++)
			{
				radii[i] = MinimumCoveringRadius(GetConfigsFunction(i));
#pragma omp critical
				{
					pd++;
					//std::cout<<radii[i]<<'\n';
				}
			}
			HistogramGenerator gen;
			gen.GenerateBins(radii, 1.0, 5.0);
			HistogramToPDF(gen, result);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "covering radius PDF:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix + std::string("_CoveringRadiusDistribution"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix + std::string("_CoveringRadiusDistribution"), "r", "p(r)");
			PlotFunction_Grace(result, OutputPrefix + std::string("_CoveringRadiusDistribution"), "r", "p(r)", Title);
		}
	};

	//distribution of the maximum distance so that a configuration has no overlap
	class PackingRadiusDistributionComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		PackingRadiusDistributionComputation(std::istream & ifile, std::ostream & ofile)
		{
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			std::vector<double> radii;
			radii.resize(NumConfig, 0.0);
			progress_display pd(NumConfig);
			double sum1 = 0.0, sumr = 0.0, sumPackingFraction = 0.0;
#pragma omp parallel for schedule(guided) reduction(+:sum1, sumr, sumPackingFraction)
			for (int i = 0; i<NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				radii[i] = MinDistance(c)*0.5;
				sum1 += 1.0;
				sumr += radii[i];
				sumPackingFraction += c.NumParticle()* ::HyperSphere_Volume(c.GetDimension(), radii[i]) / c.PeriodicVolume();
#pragma omp critical
				{
					pd++;
				//std::cout<<radii[i]<<'\n';
				}
			}
			HistogramGenerator gen;
			gen.GenerateBins(radii, 1.0, 5.0);
			HistogramToPDF(gen, result);

			std::cout << "Average r=" << sumr / sum1 << ", packing fraction=" << sumPackingFraction / sum1 << '\n';
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "pakcing radius PDF:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix + std::string("_PackingRadiusDistribution"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix + std::string("_PackingRadiusDistribution"), "r", "p(r)");
			PlotFunction_Grace(result, OutputPrefix + std::string("_PackingRadiusDistribution"), "r", "p(r)", Title);
		}
	};

	//calculate the volume fraction at the percolation threshould.
	//the percolation diameter can be calculated precisely, 
	//however, the volume fraction is calculated by digitizing the configuration.
	class PercolationVolumeFractionDistribution : public Computation
	{
	public:
		std::vector<GeometryVector> pdf;
		std::vector<GeometryVector> cdf;
		double resolution;
		size_t MeshSide;
		size_t SampleNumber;
		PercolationVolumeFractionDistribution(std::istream & ifile, std::ostream & ofile)
		{
			this->resolution = 1.0;
			std::cout << "size of the mesh=";
			std::cin >> MeshSide;
			std::cout << "sample per configuration=";
			std::cin >> SampleNumber;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			RandomGenerator gen(15469872);
			std::vector<double> phis;
			progress_display pd(NumConfig*SampleNumber);
			omp_lock_t genlock, phislock;
			omp_init_lock(&genlock);
			omp_init_lock(&phislock);

#pragma omp parallel for schedule(guided)
			for (long i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				DimensionType dim = c.GetDimension();
				long end = c.NumParticle()*dim;
				for (long j = 0; j < SampleNumber; j++)
				{
					omp_set_lock(&genlock);
					long temp = gen.RandomDouble()*end;
					omp_unset_lock(&genlock);
					long np = temp / dim;
					long nd = temp % dim;
					double phi = Volume(c, PercolationDiameter(c, np, nd)*0.5, MeshSide)/c.PeriodicVolume();
					//double phi = PercolationDiameter(c, np, nd)*0.5;
					omp_set_lock(&phislock);
					phis.push_back(phi);
					pd++;
					omp_unset_lock(&phislock);
				}
			}
			omp_destroy_lock(&genlock);
			omp_destroy_lock(&phislock);

			HistogramGenerator hgen;
			hgen.GenerateBins(phis, 1.0, resolution);
			HistogramToPDF(hgen, pdf);
			HistogramToCDF(hgen, cdf);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "perculation volume fraction PDF:\n";
			WriteFunction(pdf, logfile);
			WriteFunction(pdf, OutputPrefix + std::string("_PercolationVolumeFractionPDF"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_Grace(pdf, OutputPrefix + std::string("_PercolationVolumeFractionPDF"), "\\xf", "p(\\xf)", Title);
			PlotFunction_Grace(cdf, OutputPrefix + std::string("_PercolationVolumeFractionCDF"), "\\xf\\s0", "P(\\xf<f\\s0\\N)", Title);
		}
		virtual void SetResolutionPreference(double Preference)
		{
			resolution = Preference;
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "ResolutionPreference")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> resolution;
			else
				output << "Unrecognized command!\n";
		}
	};

	//for each D
	//calculate the probability that if each particle is replaced with a disk of diameter D
	//a particle connects to its periodic image in one direction but not another
	//both directions are selected randomly
	class PercolationP1Calculation : public Computation
	{
	public:
		std::vector<std::vector<GeometryVector>> result;
		std::vector<std::string> legends;
		size_t SampleNumber;
		PercolationP1Calculation(std::istream & ifile, std::ostream & ofile)
		{
			std::cout << "sample per configuration=";
			std::cin >> SampleNumber;
			result.resize(2);
			legends.push_back("Simulation");
			legends.push_back("Fit");
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result[0].clear();
			result[1].clear();
			struct DataStru
			{
				double r;
				signed char sign;
				DataStru(double r, signed char sign) : r(r), sign(sign)
				{}
			};
			RandomGenerator gen(15469873);
			std::vector<DataStru> datas;
			progress_display pd(NumConfig*SampleNumber);
			omp_lock_t genlock, phislock;
			omp_init_lock(&genlock);
			omp_init_lock(&phislock);

#pragma omp parallel for schedule(guided)
			for (long i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				DimensionType dim = c.GetDimension();
				long end = c.NumParticle()*dim*(dim - 1);
				for (long j = 0; j < SampleNumber; j++)
				{
					omp_set_lock(&genlock);
					long temp = gen.RandomDouble()*end;
					omp_unset_lock(&genlock);
					long np = temp / (dim*(dim - 1));
					long ndall = temp % (dim*(dim - 1));
					long nd1 = ndall / dim;
					long nd2 = ndall % dim;
					if (nd1 >= nd2)
						nd1++;
					double r1 = PercolationDiameter(c, np, nd1);
					double r2 = PercolationDiameter(c, np, nd2);

					omp_set_lock(&phislock);
					datas.push_back(DataStru(std::min(r1, r2), 1));
					datas.push_back(DataStru(std::max(r1, r2), -1));
					pd++;
					omp_unset_lock(&phislock);
				}
			}
			omp_destroy_lock(&genlock);
			omp_destroy_lock(&phislock);

			std::sort(datas.begin(), datas.end(), [](const DataStru & left, const DataStru & right) -> bool
			{
				return left.r < right.r;
			});

			long long sum = 0;
			long long max = NumConfig*SampleNumber;
			auto datasize = datas.size();
			long increment = std::max<unsigned long long>(datasize / 1000, (unsigned long long)(1));
			auto begin = datas.begin();
			for (auto iter = begin; iter != datas.end(); iter++)
			{
				sum += iter->sign;
				if ((iter - begin) % increment == 0)
				{
					result[0].push_back(GeometryVector(iter->r, (double)(sum) / max));
				}
			}

			{
				double max = std::max_element(result[0].begin(), result[0].end(), [](const GeometryVector & left, const GeometryVector & right) -> bool
				{
					return left.x[1] < right.x[1];
				})->x[1];
				std::vector<std::vector<double> > x(3, std::vector<double>());
				std::vector<double> y;
				for (auto iter = result[0].begin(); iter != result[0].end(); iter++)
				{
					if (iter->x[1]>0.9*max)
					{
						x[0].push_back(1.0);
						x[1].push_back(iter->x[0]);
						x[2].push_back(iter->x[0] * iter->x[0]);
						y.push_back(iter->x[1]);
					}
				}
				if (y.size() > 3)
				{
					std::vector<double> c = MultiVariableLinearFit(y, x);
					for (auto iter = result[0].begin(); iter != result[0].end(); iter++)
					{
						if (iter->x[1] > 0.9*max)
						{
							double x = iter->x[0];
							double y = c[0] + c[1] * x + c[2] * x*x;
							result[1].push_back(GeometryVector(x, y));
						}
					}
					std::cout << "Fit result: P1=" << c[0] << "+" << c[1] << "*D" << c[2] << "*D^2\n";
					std::cout << "Peak at D=" << (-0.5)*c[1] / c[2] << '\n';
				}
				else
					std::cout << "Warning in PercolationP1Calculation : too few data points near peak, cannot fit.\n";
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "perculation P1(D):\n";
			WriteFunction(result[0], logfile);
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_Grace(&result[0], 2, OutputPrefix + std::string("_PercolationP1"), "D", "P\\s1\\N(D)", legends, Title);
		}
	};
	class PercolationP1Calculation_v2 : public Computation
	{
	public:
		std::vector<std::vector<GeometryVector>> result;
		std::vector<std::string> legends;
		size_t SampleNumber;
		double maxD;
		PercolationP1Calculation_v2(std::istream & ifile, std::ostream & ofile)
		{
			std::cout << "min, increment, and max D=";
			double min, inc, max;
			std::cin >> min >> inc >> max;
			maxD = max;
			result.resize(2);

			for (double x = min; x < max; x += inc)
				result[0].push_back(GeometryVector(x, 0.0));

			legends.push_back("Simulation");
			legends.push_back("Fit");
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			//calculate result[0]
			{
				RandomGenerator gen(15469873);
				omp_lock_t genlock, pdlock, sumlock;
				omp_init_lock(&genlock);
				omp_init_lock(&pdlock);
				omp_init_lock(&sumlock);
				double sumN = 0;
				progress_display pd(NumConfig);

#pragma omp parallel default(shared) reduction(+:sumN)
				{
					std::vector<size_t> ThreadCount(result[0].size(), 0);
#pragma omp for schedule(guided)
					for (long i = 0; i < NumConfig; i++)
					{
						Configuration c = GetConfigsFunction(i);
						DimensionType dim = c.GetDimension();
						size_t N = c.NumParticle();

						c.SetCellSize(0.4*maxD);
						c.RefineCellList();
						//determine two random dimensions
						long end = dim*(dim - 1);
						omp_set_lock(&genlock);
						long temp = gen.RandomDouble()*end;
						omp_unset_lock(&genlock);
						long nd1 = temp / dim;
						long nd2 = temp % dim;
						if (nd1 >= nd2)
							nd1++;
						//generate two multiplicated configurations
						std::vector<size_t> Multiplicity(dim, 1);
						Multiplicity[nd1] = 2;
						Configuration m1 = MultiplicateStructure(c, Multiplicity);
						Multiplicity[nd1] = 1;
						Multiplicity[nd2] = 2;
						Configuration m2 = MultiplicateStructure(c, Multiplicity);

						//generate two corresponding ClusterMerger
						ClusterMerger cm1(m1, maxD);
						ClusterMerger cm2(m2, maxD);

						//calculation
						for (size_t i = 0; i < result[0].size(); i++)
						{
							double D = result[0][i].x[0];
							cm1.Proceed(D);
							cm2.Proceed(D);
							for (size_t j = 0; j < N; j++)
							{
								size_t n1 = 2 * j, n2 = 2 * j + 1;
								if ((cm1.affiliation[n1] == cm1.affiliation[n2]) != (cm2.affiliation[n1] == cm2.affiliation[n2]))
								{
									ThreadCount[i]++;
								}
							}
						}

						omp_set_lock(&pdlock);
						pd++;
						omp_unset_lock(&pdlock);
						sumN += N;
					}
					omp_set_lock(&sumlock);
#pragma omp flush
					for (size_t i = 0; i < result[0].size(); i++)
						result[0][i].x[1] += ThreadCount[i];
					omp_unset_lock(&sumlock);
				}
				omp_destroy_lock(&genlock);
				omp_destroy_lock(&pdlock);
				omp_destroy_lock(&sumlock);

				//normalize
				for (auto iter = result[0].begin(); iter != result[0].end(); ++iter)
					iter->x[1] /= sumN;
			}


			//calculate result[1]
			{
				result[1].clear();
				double max = std::max_element(result[0].begin(), result[0].end(), [](const GeometryVector & left, const GeometryVector & right) -> bool
				{
					return left.x[1] < right.x[1];
				})->x[1];
				std::vector<std::vector<double> > x(3, std::vector<double>());
				std::vector<double> y;
				for (auto iter = result[0].begin(); iter != result[0].end(); iter++)
				{
					if (iter->x[1]>0.9*max)
					{
						x[0].push_back(1.0);
						x[1].push_back(iter->x[0]);
						x[2].push_back(iter->x[0] * iter->x[0]);
						y.push_back(iter->x[1]);
					}
				}
				if (y.size() > 3)
				{
					std::vector<double> c = MultiVariableLinearFit(y, x);
					for (auto iter = result[0].begin(); iter != result[0].end(); iter++)
					{
						if (iter->x[1] > 0.9*max)
						{
							double x = iter->x[0];
							double y = c[0] + c[1] * x + c[2] * x*x;
							result[1].push_back(GeometryVector(x, y));
						}
					}
					std::cout << "Fit result: P1=" << c[0] << "+" << c[1] << "*D" << c[2] << "*D^2\n";
					std::cout << "Peak at D=" << (-0.5)*c[1] / c[2] << '\n';
				}
				else
					std::cout << "Warning in PercolationP1Calculation : too few data points near peak, cannot fit.\n";
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "perculation P1(D):\n";
			WriteFunction(result[0], logfile);
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_Grace(&result[0], 2, OutputPrefix + std::string("_PercolationP1_v2"), "D", "P\\s1\\N(D)", legends, Title);
		}
	};
	class VoronoiVolumeCorrelationComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double MaxDist, RPrecision;
		VoronoiVolumeCorrelationComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"Max Distance=";
			ifile>>MaxDist;
			ofile<<"r Precision=";
			ifile>>RPrecision;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::VoronoiVolumeCorrelation(GetConfigsFunction, NumConfig, result, MaxDist, RPrecision);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Voronoi Volume Correlation Function:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_VoronoiVolumeCorrelation"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix+std::string("_VoronoiVolumeCorrelation"), "r", "c(r)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_VoronoiVolumeCorrelation"), "r", "c(r)", Title);
		}
	};
	class Psi6CorrelationComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double MaxDist, RPrecision;
		Psi6CorrelationComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"Max Distance=";
			ifile>>MaxDist;
			ofile<<"r Precision=";
			ifile>>RPrecision;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			::Psi6Correlation(GetConfigsFunction, NumConfig, result, MaxDist, RPrecision);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Psi_6 Correlation Function:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_Psi6Correlation"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix+std::string("_Psi6Correlation"), "r", "g_6(r)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_Psi6Correlation"), "r", "g\\s6\\N(r)", Title);
		}
	};
	class LocalQ6DistributionComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double average;
		int NeighborType;
		LocalQ6DistributionComputation(std::istream & ifile, std::ostream & ofile)
		{
			std::cout << "Neighbor type (see definition of Psi6() in PeriodicCellList.h) =";
			std::cin >> NeighborType;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			std::vector<double> psi6s;
			average = 0.0;
			long long sum1 = 0;
			progress_display pd(NumConfig);
#pragma omp parallel 
			{
				std::vector<double> threadpsi6s;
#pragma omp for schedule(dynamic)
				for (long i = 0; i < NumConfig; i++)
				{
					Configuration c = GetConfigsFunction(i);
					DimensionType dim = c.GetDimension();
					for (size_t j = 0; j < c.NumParticle(); j++)
					{
						double p2;
						if (dim == 2)
						{
							std::complex<double> p = Psi6(c, j, NeighborType);
							p2 = p.real()*p.real() + p.imag()*p.imag();
						}
						else if (dim == 3)
						{
							p2 = 0.0;
							for (int m = -6; m <= 6; m++)
							{
								std::complex<double> p = Psi6(c, j, NeighborType, m);
								p2 += p.real()*p.real() + p.imag()*p.imag();
							}
							p2 *= (4.0*pi / 13);
						}
						double pm = std::sqrt(p2);
#pragma omp atomic
						average += pm;
#pragma omp atomic
						sum1++;
						threadpsi6s.push_back(pm);
					}
#pragma omp critical
					{
						pd++;
					}
				}
#pragma omp critical
				{
					psi6s.insert(psi6s.end(), threadpsi6s.begin(), threadpsi6s.end());
				}
			}
			average /= sum1;
			HistogramGenerator gen;
			gen.GenerateBins(psi6s, 1.0, 1.0);
			HistogramToPDF(gen, result);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "|Psi_6| PDF:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix + std::string("_Psi6ModulusSquaredDistribution"));
			std::cout << "Average |Psi_6| = " << average << '\n';
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_Grace(result, OutputPrefix + std::string("_Psi6ModulusSquaredDistribution"), "|\\xY\\N\\s6\\N|", "P(|\\xY\\N\\s6\\N|)", Title);
		}
	};
	class WindowNumberVarianceComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		size_t SampleSize;
		int seed;
		WindowNumberVarianceComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"Enter min, increment, and max window size:";
			double min, inc, max;
			ifile>>min;
			ifile>>inc;
			ifile>>max;
			for(double x=min; x<max; x+=inc)
			{
				result.push_back(GeometryVector(x, 0.0));
			}
			ofile<<"Enter sample size per configuration per window size:";
			ifile>>SampleSize;
			ofile<<"Enter Random Seed:";
			ifile>>seed;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			size_t Numx=result.size();
			std::vector<double> sumc(Numx, 0.0), sumc2(Numx, 0.0);
			omp_lock_t DisplayLock;
			omp_init_lock(&DisplayLock);
			std::cout<<"Computing Window Number Variance";
			progress_display pd(NumConfig);
			for(signed long i=0; i<NumConfig; i++)
			{
				//if(Verbosity>3 || (Verbosity>2&&i%100==0) )
				//	std::cout<<i<<"/"<<NumConfig<<"configurations processed\n";
				Configuration c=GetConfigsFunction(i);
				c.SetSortedCellList(true);
				double approximateLengthScale = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / c.GetDimension());
				c.SetCellSize(2.0*approximateLengthScale);
				c.RefineCellList();
				c.PrepareIterateThroughNeighbors(result.back().x[0]);

				DimensionType dim=c.GetDimension();
#pragma omp parallel for schedule(dynamic) 
				for(signed long j=0; j<result.size(); j++)
				{
					RandomGenerator gen((seed+1)*(i+1)*(j+1));
					double x=result[j].x[0];
					double partSumc =0, partSumc2=0;
					for(size_t k=0; k<this->SampleSize; k++)
					{
						size_t count=0;
						GeometryVector r(dim);
						for(DimensionType d=0; d<dim; d++)
							r.x[d]=gen.RandomDouble();
						c.IterateThroughNeighbors(r, x, [&count] (const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
						{
							count++;
						});
						partSumc+=count;
						partSumc2+=count*count;
					}
					double & t1=sumc[j];
#pragma omp atomic
					t1+=partSumc;
					double & t2=sumc2[j];
#pragma omp atomic
					t2+=partSumc2;
				}
				omp_set_lock(&DisplayLock);
				pd++;
				omp_unset_lock(&DisplayLock);
			}
			omp_destroy_lock(&DisplayLock);
			for(size_t j=0; j<result.size(); j++)
			{
				size_t NumSample=NumConfig*this->SampleSize;
				double c2a=sumc2[j]/NumSample;
				double ca=sumc[j]/NumSample;
				double variance = c2a-ca*ca;
				result[j].x[1]=variance;
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Number Variance:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_WindowNumberVariance"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix+std::string("_WindowNumberVariance"), "R", "\\sigma^2(R)");
			PlotFunction_Grace(result, OutputPrefix+std::string("_WindowNumberVariance"), "R", "\\xs\\f{}\\S2\\N(R)", Title);
		}
	};

	//calculate window number variance using expressions (28) and (A4) of paper-211
	class AnalyticWindowNumberVarianceComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double kmax;
		AnalyticWindowNumberVarianceComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter min, increment, and max window size:";
			double min, inc, max;
			ifile >> min;
			ifile >> inc;
			ifile >> max;
			for (double x = min; x<max; x += inc)
			{
				result.push_back(GeometryVector(x, 0.0));
			}
			ofile << "Enter max k in integration";
			ifile >> kmax;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			progress_display pd(NumConfig);
			for (size_t i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				DimensionType d = c.GetDimension();
				//calculate S(k)
				struct skType
				{ 
					GeometryVector k; 
					double s;
				};
				std::vector<skType> sks;
				GeometryVector rbas[::MaxDimension];
				for (DimensionType j = 0; j < d; j++)
					rbas[j] = c.GetReciprocalBasisVector(j);
				PeriodicCellList<Empty> rbasList(d, rbas, ::MaxDistance);
				rbasList.Insert(Empty(), GeometryVector(d));
				auto IterateFunc = [&sks](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
				{
					if (shift.Modulus2() > 0.0)
					{
						skType temp;
						temp.k = shift;
						temp.s = 0.0;
						sks.push_back(temp);
					}
				};
				rbasList.IterateThroughNeighbors(GeometryVector(d), kmax, IterateFunc);
				auto end = sks.size();
#pragma omp parallel for
				for (long i = 0; i < end; i++)
					sks[i].s = StructureFactor(c, sks[i].k);
				//summation
				double coef = c.NumParticle() / c.PeriodicVolume()* boost::math::tgamma(1.0 + 0.5*d) / std::pow(::pi, 0.5*d) * rbasList.PeriodicVolume();
				for (auto iter = result.begin(); iter != result.end(); ++iter)
				{
					double r = iter->x[0];
					double sum = 0.0;
					for (auto iter2 = sks.begin(); iter2 != sks.end(); iter2++)
					{
						double kl = std::sqrt(iter2->k.Modulus2());
						double j = boost::math::cyl_bessel_j(0.5*d, r*kl);
						sum += iter2->s*j*j / std::pow(kl, (double)(d));
					}
					iter->x[1] += sum * coef* HyperSphere_Volume(d, r);
				}
				pd++;
			}
			for (auto iter = result.begin(); iter != result.end(); ++iter)
				iter->x[1] /= NumConfig;
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "Analytical Number Variance:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix + std::string("_AnalyticWindowNumberVariance"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix + std::string("_AnalyticWindowNumberVariance"), "R", "\\sigma^2(R)");
			PlotFunction_Grace(result, OutputPrefix + std::string("_AnalyticWindowNumberVariance"), "R", "\\xs\\f{}\\S2\\N(R)", Title);
		}
	};
	class VarianceOverRd_1Computation : public WindowNumberVarianceComputation
	{
	public:
		DimensionType dim;
		VarianceOverRd_1Computation(std::istream & ifile, std::ostream & ofile): WindowNumberVarianceComputation(ifile, ofile)
		{
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			Configuration c0=GetConfigsFunction(0);
			dim=c0.GetDimension();
			WindowNumberVarianceComputation::Compute(GetConfigsFunction, NumConfig);
			for(auto iter=this->result.begin(); iter!=this->result.end(); iter++)
				iter->x[1]/=std::pow(iter->x[0], (double)(dim-1) );
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Number Variance over R^{d-1}:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+std::string("_VarianceOverRd_1"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream d1;
			d1<<dim-1;
			std::string lab1=std::string("\\sigma^2(r)/r^")+d1.str();
			std::string lab2=std::string("\\xs\\f{}\\S2\\N(r)/r\\S")+d1.str();
			PlotFunction_MathGL(result, OutputPrefix+std::string("_VarianceOverRd_1"), "r", lab1);
			PlotFunction_Grace(result, OutputPrefix+std::string("_VarianceOverRd_1"), "r", lab2, Title);
		}
	};
	class WindowNumberDistributionComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		double Radius;
		size_t SampleSize;
		int seed;
		std::string prefix;
		WindowNumberDistributionComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"Enter window radius:";
			ifile>>Radius;
			ofile<<"Enter sample size per configuration per window size:";
			ifile>>SampleSize;
			ofile<<"Enter Random Seed:";
			ifile>>seed;
			std::stringstream ss;
			ss<<"_"<<Radius<<"_WindowNumberDistribution";
			prefix=ss.str();
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			omp_lock_t DisplayLock;
			omp_init_lock(&DisplayLock);
			std::cout<<"Computing Window Number Distribution";
			progress_display pd(NumConfig);
			std::map<size_t, size_t> counts;
#pragma omp parallel
			{
				std::map<size_t, size_t> mycounts;
#pragma omp for schedule(guided)
				for(signed long i=0; i<NumConfig; i++)
				{
					//if(Verbosity>3 || (Verbosity>2&&i%100==0) )
					//	std::cout<<i<<"/"<<NumConfig<<"configurations processed\n";
					omp_set_lock(&DisplayLock);
					pd++;
					omp_unset_lock(&DisplayLock);

					Configuration c=GetConfigsFunction(i);
					RandomGenerator gen((seed+1)*(i+1));
					DimensionType dim=c.GetDimension();
					{
						for(size_t k=0; k<this->SampleSize; k++)
						{
							size_t count=0;
							GeometryVector r(dim);
							for(DimensionType d=0; d<dim; d++)
								r.x[d]=gen.RandomDouble();
							c.IterateThroughNeighbors(r, Radius, [&count] (const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
							{
								count++;
							});
							{
								std::map<size_t, size_t>::iterator iter=mycounts.find(count);
								if(iter==mycounts.end())
									mycounts.insert(std::make_pair(count, (size_t)(1)));
								else
									iter->second++;
							}
						}
					}
				}
#pragma omp critical
				{
					for(auto iter=mycounts.begin(); iter!=mycounts.end(); iter++)
					{
						auto iter2=counts.find(iter->first);
						if(iter2==counts.end())
							counts.insert(*iter);
						else
							iter2->second+=iter->second;
					}
				}
			}
			omp_destroy_lock(&DisplayLock);
			double totalCount=0;
			for(auto iter=counts.begin(); iter!=counts.end(); iter++)
				totalCount+=iter->second;
			for(auto iter=counts.begin(); iter!=counts.end(); iter++)
				result.push_back(GeometryVector((double)(iter->first), (double)(iter->second)/totalCount));
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile<<"Window number Distribution:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix+prefix);
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_MathGL(result, OutputPrefix+prefix, "N", "p(N)");
			PlotFunction_Grace(result, OutputPrefix+prefix, "N", "p(N)", Title);
		}
	};

	//calculate average cluster size for a bunch of radii, until a particle is connected to its periodic image
	class AverageClusterSizeComputation : public Computation
	{
	public:
		std::vector<GeometryVector> result;
		size_t SampleSize;
		int seed;
		std::string prefix;
		double PercolationRadius;//a particle has been found to connect to its periodic image at this radius, therefore calculation for higher radii is futile
		AverageClusterSizeComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter min, increment, and radius:";
			double min, inc, max;
			ifile >> min;
			ifile >> inc;
			ifile >> max;
			ofile << "Enter sample size per configuration per radius:";
			ifile >> SampleSize;
			ofile << "Enter Random Seed:";
			ifile >> seed;
			for (double x = min; x<max; x += inc)
			{
				result.push_back(GeometryVector(x, 0.0));
			}
			std::stringstream ss;
			ss << "_AverageClusterSize";
			prefix = ss.str();
			PercolationRadius = ::MaxDistance;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			omp_lock_t DisplayLock, PercolationRadiusLock;
			omp_init_lock(&DisplayLock);
			omp_init_lock(&PercolationRadiusLock);
			std::cout << "Computing average cluster size";
			progress_display pd(NumConfig);
			std::map<size_t, size_t> counts;
#pragma omp parallel
			{
#pragma omp for schedule(guided)
				for (signed long i = 0; i<NumConfig; i++)
				{
					omp_set_lock(&DisplayLock);
					pd++;
					omp_unset_lock(&DisplayLock);

					Configuration c = GetConfigsFunction(i);
					RandomGenerator gen((seed + 1)*(i + 1));
					DimensionType dim = c.GetDimension();

					for (auto iter = result.begin(); iter != result.end(); ++iter)
					{
						double r = iter->x[0];
						omp_set_lock(&PercolationRadiusLock);
						if (r > PercolationRadius)
						{
							omp_unset_lock(&PercolationRadiusLock);
							break;
						}
						omp_unset_lock(&PercolationRadiusLock);
						for (size_t j = 0; j < SampleSize; j++)
						{
							bool percolating;
							size_t csize = ClusterSize(c, c.GetRandomParticle(gen), r, percolating);
							if (percolating)
							{
								omp_set_lock(&PercolationRadiusLock);
								PercolationRadius = std::min(PercolationRadius, r);
								omp_unset_lock(&PercolationRadiusLock);
							}
							else
							{
#pragma omp atomic
								iter->x[1] += csize;
							}
						}
					}
				}
			}
			omp_destroy_lock(&DisplayLock);
			omp_destroy_lock(&PercolationRadiusLock);
			size_t AvailableDataSize = result.size();
			for (auto iter = result.begin(); iter != result.end(); ++iter)
			{
				if (iter->x[0] > PercolationRadius)
				{
					std::cout << "Percolation detected at r=" << PercolationRadius << ", remove data beyond.\n";
					AvailableDataSize = iter - result.begin();
					break;
				}
				else
					iter->x[1] /= (double)(SampleSize)*(double)(NumConfig);
			}
			result.resize(AvailableDataSize);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "average cluster size:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, OutputPrefix + prefix);
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			//PlotFunction_MathGL(result, OutputPrefix + prefix, "N", "p(N)");
			PlotFunction_Grace(result, OutputPrefix + prefix, "r", "average cluster size", Title);
		}
	};
	class NeighborLinkTortuosityComputation : public Computation
	{
	protected:
		Configuration myc0;
		std::vector<size_t> mypath0;
	public:
		std::vector<GeometryVector> result;
		size_t NLink;
		NeighborLinkTortuosityComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile<<"Number of Link=";
			ifile>>this->NLink;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();

			std::vector<double> Tortuosity;

			std::cout<<"\nTortuosity computation:";
			progress_display pd(NumConfig);
			for(int i=0; i<NumConfig; i++)
			{
				//if(Verbosity>3 || (Verbosity>2&&i%100==0) )
				//	std::cout<<i<<"/"<<NumConfig<<"configurations processed\n";
				pd++;
				typedef std::pair<size_t, GeometryVector> neighbor;
				Configuration c=GetConfigsFunction(i);
				double TypicalLength=std::pow(c.PeriodicVolume()/c.NumParticle(), 1.0/c.GetDimension())*1.5;

				for(size_t jj=0; jj<c.NumParticle(); jj++)
				{
					std::set<size_t> included;
					std::vector<GeometryVector> displacements;
					size_t j=jj;
					included.insert(j);

					std::vector<size_t> path;

					for(size_t n=0; n<NLink; n++)
					{
						std::vector<neighbor> neighbors;
						double l=TypicalLength;
						bool found=false;//found the next particle to add in path
						while(found==false)
						{
							neighbors.clear();
							c.IterateThroughNeighbors(j, l, [&neighbors](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
							{
								neighbors.push_back(neighbor(Sourceparticle, shift));
							});
							l*=2;
							std::sort(neighbors.begin(), neighbors.end(), [](const neighbor & left, const neighbor & right)->bool{return left.second.Modulus2()<right.second.Modulus2();});
							for(auto iter=neighbors.begin(); iter != neighbors.end(); iter++)
							{
								if(included.find(iter->first)==included.end())
								{
									GeometryVector start=c.GetCartesianCoordinates(j);
									GeometryVector end=start+iter->second;
									displacements.push_back(iter->second);

									j=iter->first;
									found=true;
									included.insert(iter->first);

									if(jj==0 && i==0)
										path.push_back(j);

									break;
								}
							}
						}
					}

					//prepare to show the path of config0::particle0 as an example
					if(jj==0 && i==0)
					{
						myc0 = c;
						mypath0 = path;
					}

					//process vector "displacements" to get a lengthratio
					double TotalLength=0;
					GeometryVector TotalDisplacement=GeometryVector(c.GetDimension());
					for(auto iter=displacements.begin(); iter!=displacements.end(); iter++)
					{
						TotalLength+=std::sqrt(iter->Modulus2());
						TotalDisplacement.AddFrom(*iter);
					}
					//output length ratio
					Tortuosity.push_back(std::sqrt(TotalDisplacement.Modulus2())/TotalLength);
				}
			}

			//debug temp
			double SumTortuosity=0;
			double SumTortuosity2=0;
			for(auto iter=Tortuosity.begin(); iter!=Tortuosity.end(); iter++)
			{
				SumTortuosity+=(*iter);
				SumTortuosity2+=(*iter)*(*iter);
			}
			std::cout<<"Average Tortuosity="<<SumTortuosity/Tortuosity.size()<<'\n';
			std::cout<<"Std. deviation Tortuosity="<<std::sqrt((SumTortuosity2/Tortuosity.size())-(SumTortuosity/Tortuosity.size())*(SumTortuosity/Tortuosity.size()))<<'\n';

			HistogramGenerator HGen;
			HGen.GenerateBins(Tortuosity, 100.0, 1.0);
			HistogramToPDF(HGen, result);

			return;
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss<<OutputPrefix<<'_'<<this->NLink<<"_NeighborLinkTortuosity";
			logfile<<"Neighbor link tortuosity:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss<<OutputPrefix<<'_'<<this->NLink<<"_NeighborLinkTortuosity";
			//PlotFunction_MathGL(result, ss.str(), "t=1/\tau", "p(t)");
			PlotFunction_Grace(result, ss.str(), "t=1/\\xt", "p(t)", Title);
			std::stringstream ss2;
			ss2 << OutputPrefix << "NeighborLinkPath";
			::PlotPath(ss2.str(), myc0, "", mypath0);
			//debug temp
			//for (auto iter = mypath0.begin(); iter != mypath0.end(); ++iter)
			//	std::cout << *iter << '\n';
		}
	};

	//helper class for M2Computation
	class ClusterSizeCalculator: public ClusterMerger
	{
	public:
		ClusterSizeCalculator(const PeriodicCellList<Empty> & c, double Rmax) : ClusterMerger(c, Rmax)
		{}
		ClusterSizeCalculator(size_t N, const std::vector<Bond> & Bonds) : ClusterMerger(N, Bonds)
		{}
		double Smax(void)
		{
			return LargestClusterSize;
		}
		double SumSiSquare(void)
		{
			double result = 0.0;
			for (auto iter = clusters.begin(); iter != clusters.end(); iter++)
			{
				size_t s = iter->size();
				result += s*s*s;
			}
			return result;
		}
	};
	//calculate M_2 defined in "Percolation of disordered Jammed sphere packings" by Ziff and Torquato
	//here M_2 is a function of D
	//where any two particles within distance D are connected
	class M2Computation : public Computation
	{
	protected:
		std::vector<GeometryVector> result;
	public:
		M2Computation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Min, increment, and max D=";
			double min, inc, max;
			ifile >> min >> inc >> max;
			for (double x = min; x<max; x += inc)
			{
				result.push_back(GeometryVector(x, 0.0));
			}
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			struct dataType
			{
				double D, sumMax, sumMax2;
				dataType(double D) : D(D), sumMax(0.0), sumMax2(0.0)
				{
				}
			};
			std::vector<dataType> data;
			for (auto iter = result.begin(); iter != result.end(); iter++)
				data.push_back(dataType(iter->x[0]));
			progress_display pd(NumConfig);
#pragma omp parallel for schedule(guided)
			for (long i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				//temp: set number density to 1.0
				//c.Resize(c.NumParticle());
				c.SetSortedCellList(true);
				double approximateLengthScale = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / c.GetDimension());
				c.SetCellSize(1.0*approximateLengthScale);
				c.RefineCellList();
				ClusterSizeCalculator ca(c, data.back().D);
				for (auto iter = data.begin(); iter != data.end(); ++iter)
				{
					ca.Proceed(iter->D);
					double smax = ca.Smax();
#pragma omp atomic
					iter->sumMax += smax;
#pragma omp atomic
					iter->sumMax2 += smax*smax;
				}
#pragma omp critical
				{
					pd++;
				}
			}
			for (size_t i = 0; i < result.size(); i++)
			{
				double aveMax = data[i].sumMax / NumConfig;
				double aveMax2 = data[i].sumMax2 / NumConfig;
				result[i].x[1] = aveMax2 / aveMax / aveMax - 1.0;
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_M2";
			logfile << "M2:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_M2";
			PlotFunction_Grace(result, ss.str(), "D", "M\\s2\\N(D)", Title);
		}
	};
	class VoidPhaseM2Computation : public Computation
	{
	protected:
		std::vector<GeometryVector> result;
	public:
		VoidPhaseM2Computation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Min, increment, and max D=";
			double min, inc, max;
			ifile >> min >> inc >> max;
			for (double x = min; x<max; x += inc)
			{
				result.push_back(GeometryVector(x, 0.0));
			}
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			struct dataType
			{
				double D, sumMax, sumMax2;
				dataType(double D) : D(D), sumMax(0.0), sumMax2(0.0)
				{
				}
			};
			std::vector<dataType> data;
			for (auto iter = result.begin(); iter != result.end(); ++iter)
				data.push_back(dataType(iter->x[0]));

			progress_display pd(NumConfig);
#pragma omp parallel for schedule(guided)
			for (long i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				c.SetSortedCellList(true);
				DimensionType d = c.GetDimension();
				double approximateLengthScale = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / d);
				c.SetCellSize(1.0*approximateLengthScale);
				c.RefineCellList();

				std::vector<ClusterMerger::Bond> vBonds;
				PeriodicCellList<Empty> voronoiVertices(c);
				voronoiVertices.RemoveParticles();
				double lowestl = 0.0;
				for (long j = 0; j < c.NumParticle(); j++)
				{
					std::vector<GeometryVector> vertices;
					std::vector<signed long> vertexIndexes;
					std::vector<signed long> linkage;
					GetVoronoiCell(c, j, vertices, &linkage);

					//given a vertex v, find its index in voronoiVertices
					//return -1 if not found
					auto FindVertexFunc = [&](GeometryVector v) -> signed long
					{
						GeometryVector rel = c.CartesianCoord2RelativeCoord(v);
						signed long result = -1;
						bool abort = false;
						//if two voronoi vertices are within a distance of 1e-8, we may simply confuse them into a single vertex
						voronoiVertices.IterateThroughNeighbors(rel, 1e-8, [&](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle)
						{
							result = Sourceparticle;
							abort = true;
						}, &abort);
						return result;
					};
					//add all found vertices into the list
					for (auto iter = vertices.begin(); iter != vertices.end(); ++iter)
					{
						signed long i = FindVertexFunc(*iter);
						if (i == -1)
						{
							voronoiVertices.Insert(Empty(), voronoiVertices.CartesianCoord2RelativeCoord(*iter));
							vertexIndexes.push_back(voronoiVertices.NumParticle() - 1);
						}
						else
							vertexIndexes.push_back(i);
					}
					//add all linkage information into vBonds
					for (auto iter = linkage.begin(); iter != linkage.end(); ++iter)
					{
						if (*iter == -1)
							continue;
						size_t m = (iter - linkage.begin()) / (d + 1);
						size_t n = *iter;
						signed long mm = vertexIndexes[m];
						signed long nn = vertexIndexes[n];

						if (mm > nn)
						{
							ClusterMerger::Bond b;
							b.i = mm;
							b.j = nn;
							GeometryVector v1 = vertices[m], v2 = vertices[n], vp = c.GetCartesianCoordinates(j);
							GeometryVector v1p = vp - v1, v12 = v2 - v1;
							//the projection of v1p in the direction of v12
							GeometryVector proj = v12*(v1p.Dot(v12)/v12.Dot(v12));
							//the vector from vp to the line segment defined by v12
							GeometryVector ortho = v1p - proj;
							//distance between this bound to a closest sphere
							double d = std::sqrt(ortho.Modulus2());

							//here we use the ClusterMerger class by assigning negative distance
							//normally ClusterMerger merges particles with closest distance first
							//here we want to merge voronoi vertices farthest away from particles first
							b.l = (-1.0)*d;

							vBonds.push_back(b);
							lowestl = std::min(lowestl, b.l);
						}
					}
				}

				ClusterSizeCalculator ca(voronoiVertices.NumParticle(), vBonds);

				for (auto iter = data.rbegin(); iter !=data.rend(); ++iter)
				{
					ca.Proceed((-1.0)*iter->D);
					double smax = ca.Smax();
#pragma omp atomic
					iter->sumMax += smax;
#pragma omp atomic
					iter->sumMax2 += smax*smax;
				}

#pragma omp critical
				{
					pd++;
				}
			}
			for (size_t i = 0; i < data.size(); i++)
			{
				double aveMax = data[i].sumMax / NumConfig;
				double aveMax2 = data[i].sumMax2 / NumConfig;
				result[i].x[1] = aveMax2 / aveMax / aveMax - 1.0;
				//debug temp
				result[i].x[2] = aveMax;
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_VoidPhaseM2";
			logfile << "VoidPhaseM2:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_VoidPhaseM2";
			PlotFunction_Grace(result, ss.str(), "D", "M\\s2\\N(D)", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			output << "Unrecognized command!\n";
		}
	};
	class VoidPhasePercolationDiameterDistribution : public Computation
	{
	public:
		std::vector<GeometryVector> pdf;
		std::vector<GeometryVector> cdf;
		double resolution;
		VoidPhasePercolationDiameterDistribution(std::istream & ifile, std::ostream & ofile)
		{
			this->resolution = 1.0;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			RandomGenerator gen(15469872);
			std::vector<double> Diameters;
			progress_display pd(NumConfig);
			omp_lock_t Diameterslock;
			omp_init_lock(&Diameterslock);

#pragma omp parallel for schedule(guided)
			for (long i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				c.SetSortedCellList(true);
				DimensionType d = c.GetDimension();
				double approximateLengthScale = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / d);
				c.SetCellSize(1.0*approximateLengthScale);
				c.RefineCellList();

				PeriodicCellList<Empty> voronoiVertices(c);
				voronoiVertices.RemoveParticles();
				double lowestl = 0.0;
				struct BondwithBoundaryInformation
				{
					double l;
					size_t i, j;
					char AcrossBoundaryFlag;//'n' for not across boundary, 'a' for crossing boundary, from the center box to the box to the right, 'o' for other
				};
				//all bounds between voronoi vertices, with whether or not such a bound crosses periodic boundary in a particular direction recorded
				std::vector<BondwithBoundaryInformation> vmyBonds;

				for (long j = 0; j < c.NumParticle(); j++)
				{
					std::vector<GeometryVector> vertices;
					std::vector<signed long> vertexIndexes;
					std::vector<signed long> linkage;
					std::vector<char> vAcrossBoundaryFlags;
					GetVoronoiCell(c, j, vertices, &linkage);
					
					//given a vertex v, find its index in voronoiVertices
					//return -1 if not found
					auto FindVertexFunc = [&](GeometryVector v) -> signed long
					{
						GeometryVector rel = c.CartesianCoord2RelativeCoord(v);
						signed long result = -1;
						bool abort = false;
						//if two voronoi vertices are within a distance of 1e-8, we may simply confuse them into a single vertex
						voronoiVertices.IterateThroughNeighbors(rel, 1e-8, [&](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle)
						{
							result = Sourceparticle;
							abort = true;
						}, &abort);
						return result;
					};
					//add all found vertices into the list
					for (auto iter = vertices.begin(); iter != vertices.end(); ++iter)
					{
						GeometryVector rel = c.CartesianCoord2RelativeCoord(*iter);
						if (rel.x[0] >= 0.0 && rel.x[0] < 1.0)
							vAcrossBoundaryFlags.push_back('n');
						else if (rel.x[0] >= 1.0 && rel.x[0] < 2.0)
							vAcrossBoundaryFlags.push_back('a');
						else if (rel.x[0] >= -1.0 && rel.x[0] < 0.0)
							vAcrossBoundaryFlags.push_back('b');
						else
							vAcrossBoundaryFlags.push_back('o');

						signed long i = FindVertexFunc(*iter);
						if (i == -1)
						{
							voronoiVertices.Insert(Empty(), voronoiVertices.CartesianCoord2RelativeCoord(*iter));
							vertexIndexes.push_back(voronoiVertices.NumParticle() - 1);
						}
						else
							vertexIndexes.push_back(i);
					}
					//add all linkage information into vBonds
					for (auto iter = linkage.begin(); iter != linkage.end(); ++iter)
					{
						if (*iter == -1)
							continue;
						size_t m = (iter - linkage.begin()) / (d + 1);
						size_t n = *iter;
						signed long mm = vertexIndexes[m];
						signed long nn = vertexIndexes[n];

						if (mm > nn)
						{
							BondwithBoundaryInformation b;
							b.i = mm;
							b.j = nn;
							GeometryVector v1 = vertices[m], v2 = vertices[n], vp = c.GetCartesianCoordinates(j);
							GeometryVector v1p = vp - v1, v12 = v2 - v1;
							//the projection of v1p in the direction of v12
							GeometryVector proj = v12*(v1p.Dot(v12) / v12.Dot(v12));
							//the vector from vp to the line segment defined by v12
							GeometryVector ortho = v1p - proj;
							//distance between this bound to a closest sphere
							double d = std::sqrt(ortho.Modulus2());

							//here we use the ClusterMerger class by assigning negative distance
							//normally ClusterMerger merges particles with closest distance first
							//here we want to merge voronoi vertices farthest away from particles first
							b.l = (-1.0)*d;

							//find out boundary information
							char f1 = vAcrossBoundaryFlags[m], f2 = vAcrossBoundaryFlags[n];
							if (f1 == 'o' || f2 == 'o')//one vertex is not relevant
								b.AcrossBoundaryFlag = 'o';
							else if ((f1 == 'a' && f2 == 'n') || (f1 == 'n' && f2 == 'b'))//one vertex is across boundary
								b.AcrossBoundaryFlag = 'a';
							else if ((f1 == 'n' && f2 == 'a') || (f1 == 'b' && f2 == 'n'))
							{
								b.AcrossBoundaryFlag = 'a';
								std::swap(b.i, b.j);
							}
							else //neither or both verteces are across boundary
								b.AcrossBoundaryFlag = 'n';

							vmyBonds.push_back(b);
							lowestl = std::min(lowestl, b.l);
						}
					}
				}

				std::vector<ClusterMerger::Bond> vBonds;
				size_t NVertices = voronoiVertices.NumParticle();
				//translate vmyBonds into vBounds, multiplicating the configuration
				for (auto iter = vmyBonds.begin(); iter != vmyBonds.end(); ++iter)
				{
					ClusterMerger::Bond b;
					if (iter->AcrossBoundaryFlag == 'a')
					{
						b.i = iter->i + NVertices;
						b.j = iter->j;
						b.l = iter->l;
						vBonds.push_back(b);
					}
					else if (iter->AcrossBoundaryFlag == 'n')
					{
						b.i = iter->i;
						b.j = iter->j;
						b.l = iter->l;
						vBonds.push_back(b);
						b.i = iter->i + NVertices;
						b.j = iter->j + NVertices;
						b.l = iter->l;
						vBonds.push_back(b);
					}
				}

				ClusterMerger ca(2 * NVertices, vBonds);

				//figure out the percolation threshold
				bool ImagesMerged = false;//two images are in the same cluster
				auto MergeCallBack = [&NVertices, &ImagesMerged](size_t i, size_t j) ->void
				{
					if ((i - j == NVertices) || (j - i == NVertices))
						ImagesMerged = true;
				};
				while (!ImagesMerged)
					ca.Proceed(MergeCallBack);

				double Diameter = (-2.0)*ca.currentL;

				omp_set_lock(&Diameterslock);
				Diameters.push_back(Diameter);
				pd++;
				omp_unset_lock(&Diameterslock);
			}
			omp_destroy_lock(&Diameterslock);

			logfile << "void phase percolation at (sphere diameters):\n";
			for (auto iter = Diameters.begin(); iter != Diameters.end(); ++iter)
				logfile << *iter << "\n";

			HistogramGenerator hgen;
			hgen.GenerateBins(Diameters, 1.0, resolution);
			HistogramToPDF(hgen, pdf);
			HistogramToCDF(hgen, cdf);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			logfile << "void phase percolation sphere diameter PDF:\n";
			WriteFunction(pdf, logfile);
			WriteFunction(pdf, OutputPrefix + std::string("_VoidPhasePercolationDiameterPDF"));
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			PlotFunction_Grace(pdf, OutputPrefix + std::string("_VoidPhasePercolationDiameterPDF"), "D", "p(D)", Title);
			PlotFunction_Grace(cdf, OutputPrefix + std::string("_VoidPhasePercolationDiameterCDF"), "D\\s0", "P(D<D\\s0\\N)", Title);
		}
		virtual void SetResolutionPreference(double Preference)
		{
			resolution = Preference;
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "ResolutionPreference")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> resolution;
			else
				output << "Unrecognized command!\n";
		}
	};
	class DiscretizationVolumeFractionComputation : public Computation
	{
	protected:
		std::vector<GeometryVector> result;
		double radius;
	public:
		DiscretizationVolumeFractionComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Input diameter:";
			ifile >> radius;
			radius /= 2;
			ofile << "Min, increment, and max number of voxels per side=";
			size_t min, inc, max;
			ifile >> min >> inc >> max;
			for (size_t x = min; x<max; x += inc)
			{
				result.push_back(GeometryVector(x, 0.0));
			}
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			progress_display pd(NumConfig);
#pragma omp parallel 
			{
				std::vector<VoxelType> threadBuffer;
#pragma omp for schedule(guided)
				for (long i = 0; i < NumConfig; i++)
				{
					Configuration c = GetConfigsFunction(i);

					for (auto iter = result.begin(); iter != result.end(); ++iter)
					{
						size_t side = std::floor(iter->x[0] + 0.5);
						double phi = Volume(c, radius, side, &threadBuffer) / c.PeriodicVolume();
#pragma omp atomic
						iter->x[1] += phi;
					}
#pragma omp critical
					{
						pd++;
					}
				}
			}
			for (auto iter = result.begin(); iter != result.end(); ++iter)
			{
				iter->x[0] = 1.0 / std::floor(iter->x[0] + 0.5);
				iter->x[1] /= NumConfig;
			}
			std::cout << "From finest digitization, volume fraction = " << result.back().x[1] << '\n';
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_DiscretizationVolumeFraction";
			logfile << "DiscretizationVolumeFraction:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_DiscretizationVolumeFraction";
			PlotFunction_Grace(result, ss.str(), "1/n", "\\xf\\f{}(n)", Title);
		}
	}; 

	//calculate mean survival time using first-passage time technique
	//set difussion coefficient D=1
	class MeanSurvivalTimeComputation : public Computation
	{
	public:
		size_t SamplePerConfiguration;

		//the random walker is considered trapped when it comes to a trap closer than TrapDistanceCoeff*Radius
		//default is 1e-5;
		double TrapDistanceCoeff;

		std::vector<GeometryVector> result;

		MeanSurvivalTimeComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter sample trajectories per configuration:";
			ifile >> SamplePerConfiguration;

			ofile << "Min, increment, and max trap radius=";
			double min, inc, max;
			ifile >> min >> inc >> max;
			for (double r = min; r < max; r += inc)
				result.push_back(GeometryVector(r, 0.0, 0.0, 0.0));

			TrapDistanceCoeff = 1e-5;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			progress_display pd(NumConfig);
			std::vector<double> sumt2(result.size(), 0.0);
			std::vector<double> sumt(result.size(), 0.0);
			std::vector<double> sum1(result.size(), 0.0);

			double TooLargeRadius = ::MaxDistance; // a radius known to be so large that initial position cannot be found in at least one configuration
			omp_lock_t TooLargeRadiusLock;
			omp_init_lock(&TooLargeRadiusLock);
#pragma omp parallel 
			{
#pragma omp for schedule(guided)
				for (long i = 0; i < NumConfig; i++)
				{
					RandomGenerator gen(i);
					Configuration c = GetConfigsFunction(i);
					DimensionType d = c.GetDimension();

					// computations
					//loop over all radii
					for (size_t m = 0; m < result.size(); m++)
					{
						double Radius = result[m].x[0];

						omp_set_lock(&TooLargeRadiusLock);
						if (Radius >= TooLargeRadius)
						{
							omp_unset_lock(&TooLargeRadiusLock);
							continue;
						}
						omp_unset_lock(&TooLargeRadiusLock);

						double TrapDistance = TrapDistanceCoeff*Radius;
						for (long j = 0; j < SamplePerConfiguration; j++)
						{
							//Generate a random point
							GeometryVector loc = GeometryVector(d);
							double dist = 0;//distance from the location to the nearest trap

							size_t count = 0;
							const size_t MaxCount = 1000000;
							do
							{
								for (DimensionType k = 0; k < d; k++)
									loc.x[k] = gen.RandomDouble();
								dist = c.NearestParticleDistance(loc) - Radius;
								if ( (++count) >= MaxCount)
								{
									//std::cout << "Warning in FirstPassageTimeComputation : did not find a non-trapping initial place!\n";
									break;
								}
							} while (dist <= 0);
							if (count >= MaxCount) //did not find a starting point outside of the spheres
							{
								omp_set_lock(&TooLargeRadiusLock);
								double temp = std::min(TooLargeRadius, Radius);
								TooLargeRadius = temp;
								omp_unset_lock(&TooLargeRadiusLock);
								break;
							}

							//first passage time iteration
							double time = 0;
							while (dist > TrapDistance)
							{
								time += dist*dist / (2.0*d);

								//move the location
								loc = c.RelativeCoord2CartesianCoord(loc);
								GeometryVector RandomDirection(d);
								GetRandomVector(d, gen, RandomDirection.x);
								loc.AddFrom(dist*RandomDirection);
								loc = c.CartesianCoord2RelativeCoord(loc);

								//calculate distance to nearest trap
								dist = c.NearestParticleDistance(loc) - Radius;

								//safety test
								if (dist < -1e-10)
								{
									std::cout << "Error in first passage time computation: particle entered the trapping phase! dist=" << dist << '\n';
								}
							}
#pragma omp atomic
							sumt2[m] += time*time;
#pragma omp atomic
							sumt[m] += time;
#pragma omp atomic
							sum1[m] += 1.0;

						}
					}
#pragma omp critical
					{
						pd++;
					}
					}
			}
			omp_destroy_lock(&TooLargeRadiusLock);

			std::vector<GeometryVector> temp;
			for (size_t m = 0; m < result.size(); m++)
			{
				if (sum1[m]>0.5 && result[m].x[0]<TooLargeRadius)
				{
					//average time
					result[m].x[1] = sumt[m] / sum1[m];
					//radius uncertainty
					result[m].x[2] = 0.0;
					//time uncertainty
					result[m].x[3] = std::sqrt((sumt2[m] / sum1[m] - result[m].x[1] * result[m].x[1]) / (sum1[m] - 1.0));

					temp.push_back(result[m]);
				}
			}
			std::swap(result, temp);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_MeanSurvivalTime";
			logfile << "MeanSurvivalTime:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_MeanSurvivalTime";
			PlotFunction_Grace(result, ss.str(), "R", "\\xt\\f{}(R)", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "TrapDistanceCoeff")
				input >> TrapDistanceCoeff;
			else
				output << "Unrecognized command!\n";
		}
	};

	//simulate Brownian motion using first-passage-time iteration
	//starting from relative coordinate loc
	//each particle in c is replaced with a impenetrable sphere of radius Radius
	//simulate until total displacement is above Rmax, total time is above Tmax, or total iteration count is above MaxIteration
	//recommended parameters : Delta1 = 1e-4*Radius, Delta2=1e-2*Radius, MaxIteration=1e6, NTrial = 1e3
	//returns a vector of (time, (delta r)^2)
	void FirstPassageTimeIteration(const Configuration & c, double Radius, RandomGenerator & gen, double Delta1, double Delta2, double Rmax, double Tmax, size_t MaxIteration, size_t NTrial, GeometryVector loc, std::function<void(const GeometryVector &)> ReportFunction)
	{
		DimensionType d = c.GetDimension();

		GeometryVector PrevIteratedCar = GeometryVector(d);
		PrevIteratedCar.x[0] = ::MaxDistance;
		double MaxNeighborListDist = 0;
		std::vector<GeometryVector> neighbors;

		//debug temp
		//auto GetDistFunc_stable = [&c](const GeometryVector & loc) ->double
		//{
		//	//re-generate neighbor list
		//	double TypicalLength = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / (c.GetDimension()))*1.0;
		//	std::vector<GeometryVector> neighbors;
		//	double l = TypicalLength / 1.5;
		//	while (neighbors.size() < 1)
		//	{
		//		l *= 1.5;
		//		neighbors.clear();
		//		c.IterateThroughNeighbors(loc, l, [&neighbors](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
		//		{
		//			neighbors.push_back(shift);
		//		});
		//	}

		//	GeometryVector nearestNeighbor = *std::min_element(neighbors.begin(), neighbors.end(), [](const GeometryVector & left, const GeometryVector & right)->bool{return left.Modulus2() < right.Modulus2(); });

		//	return std::sqrt(nearestNeighbor.Modulus2());
		//};

		auto GetDistFunc = [&c, &PrevIteratedCar, &MaxNeighborListDist, &neighbors](const GeometryVector & loc) ->double
		{
			GeometryVector car = c.RelativeCoord2CartesianCoord(loc);
			GeometryVector moved = car - PrevIteratedCar;

			if (moved.Modulus2() < MaxNeighborListDist*MaxNeighborListDist)
			{
				GeometryVector nearestNeighbor = *std::min_element(neighbors.begin(), neighbors.end(), [&moved](const GeometryVector & left, const GeometryVector & right)->bool{return (left - moved).Modulus2() < (right - moved).Modulus2(); });

				double result=std::sqrt((nearestNeighbor - moved).Modulus2());

				//debug temp
				//double StableResult = GetDistFunc_stable(loc);
				//if(std::abs(result-StableResult)>1e-10)
				//	std::cout << "result="<<result << ", stable version result=" << StableResult << '\n';

				return result;
			}
			else
			{
				//re-generate neighbor list
				double TypicalLength = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / (c.GetDimension()))*1.0;
				neighbors.clear();
				double l = TypicalLength / 1.5;
				while (neighbors.size() < 1)
				{
					l *= 1.5;
					neighbors.clear();
					c.IterateThroughNeighbors(loc, l, [&neighbors](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
					{
						neighbors.push_back(shift);
					});
				}

				PrevIteratedCar = car;
				GeometryVector nearestNeighbor = *std::min_element(neighbors.begin(), neighbors.end(), [](const GeometryVector & left, const GeometryVector & right)->bool{return left.Modulus2() < right.Modulus2(); });
				MaxNeighborListDist = 0.5 *(l - std::sqrt(nearestNeighbor.Modulus2()));

				return std::sqrt(nearestNeighbor.Modulus2());
			}
		};
		double dist = GetDistFunc(loc) - Radius;

		if (dist < 0)
			return;

		//first passage time iteration
		double time = 0;
		GeometryVector sumMove(d);
		GeometryVector carloc = c.RelativeCoord2CartesianCoord(loc);
		size_t IterationCount = 0;
		while (sumMove.Modulus2() < Rmax*Rmax && time < Tmax && IterationCount<MaxIteration)
		{
			IterationCount++;
			//find next move, and increase the time
			GeometryVector dr(d);
			if (dist > Delta1)
			{
				GeometryVector RandomDirection(d);
				GetRandomVector(d, gen, RandomDirection.x);
				dr = dist*RandomDirection;
				time += dist*dist / (2.0*d);

				//debug temp
				//if (time > 1e10)
				//	std::cout << "caught!\n";
			}
			else
			{
				std::vector<GeometryVector> relevantTraps;
				c.IterateThroughNeighbors(loc, Radius + Delta2, [&relevantTraps](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) ->void
				{
					relevantTraps.push_back(shift);
				});
				if (relevantTraps.size() == 0)
				{
					std::cout << "Error in FirstPassageTimeIteration : unexpected relevantTraps.size() !\n";
					return;
				}
				double v2Tov1;
				if (relevantTraps.size() == 1 && d == 3)
				{
					double dr = std::sqrt(relevantTraps[0].Modulus2());
					double t = Radius + Delta2 - dr;
					double v2 = pi*t*t*(dr*dr + 2 * dr*(Delta2 + Radius) - 3 * (Delta2*Delta2 + Radius*Radius) + 6 * Delta2*Radius);
					double v1 = 4 * pi*Delta2*Delta2*Delta2 / 3.0 - v2;
					v2Tov1 = v2 / v1;
				}
				else if (relevantTraps.size() == 1 && d == 2)
				{
					double dr = std::sqrt(relevantTraps[0].Modulus2());
					double v2 = Delta2*Delta2*std::acos((dr*dr + Delta2*Delta2 - Radius*Radius) / (2.0*dr*Delta2)) + Radius*Radius*std::acos((dr*dr + Radius*Radius - Delta2*Delta2) / (2.0*dr*Radius)) - 0.5*std::sqrt((Radius + Delta2 - dr)*(dr + Delta2 - Radius)*(dr - Delta2 + Radius)*(dr + Delta2 + Radius));
					double v1 = pi*Delta2*Delta2 - v2;
					v2Tov1 = v2 / v1;
				}
				else
				{
					size_t c1 = 0, c2 = 0;
					while (c1 == 0)
					{
						for (size_t i = 0; i < NTrial; i++)
						{
							GeometryVector temp(d);
							do
							{
								for (DimensionType i = 0; i < d; i++)
									temp.x[i] = gen.RandomDouble() - 0.5;
							} while (temp.Modulus2() < 0.25);
							temp.MultiplyFrom(2.0*Delta2);
							bool InPhase2 = false;
							for (auto iter = relevantTraps.begin(); iter != relevantTraps.end(); ++iter)
							{
								if (((*iter) - temp).Modulus2() < Radius*Radius)
								{
									InPhase2 = true;
									break;
								}
							}
							if (InPhase2)
								c2++;
							else
								c1++;
						}
					}
					v2Tov1 = (double)(c2) / c1;
				}

				bool InPhase2;
				do
				{
					GeometryVector RandomDirection(d);
					GetRandomVector(d, gen, RandomDirection.x);
					dr = Delta2*RandomDirection;
					InPhase2 = false;
					for (auto iter = relevantTraps.begin(); iter != relevantTraps.end(); ++iter)
					{
						if (((*iter) - dr).Modulus2() < Radius*Radius)
						{
							InPhase2 = true;
							break;
						}
					}
				} while (InPhase2);
				time += Delta2*Delta2 / (2.0*d) *(1.0 + v2Tov1);

				//debug temp
				//if (time > 1e10)
				//	std::cout << "caught!\n";
			}
			//move the particle
			carloc.AddFrom(dr);
			sumMove.AddFrom(dr);
			loc = c.CartesianCoord2RelativeCoord(carloc);

			ReportFunction(GeometryVector(time, sumMove.Modulus2()));

			//calculate distance to nearest trap
			dist = GetDistFunc(loc) - Radius;

			//safety test
			if (dist < -1e-10)
			{
				std::cout << "Error in first passage time computation: particle entered the trapping phase! dist=" << dist << '\n';
			}
		}
		return;
	}
	//same as above, but generates a random starting location
	void FirstPassageTimeIteration(const Configuration & c, double Radius, RandomGenerator & gen, double Delta1, double Delta2, double Rmax, double Tmax, size_t MaxIteration, size_t NTrial, std::function<void(const GeometryVector &)> ReportFunction)
	{
		DimensionType d = c.GetDimension();
		GeometryVector loc = GeometryVector(d);
		double dist = 0;//distance from the location to the nearest trap

		size_t count = 0;
		const size_t MaxCount = 1000000;
		do
		{
			for (DimensionType k = 0; k < d; k++)
				loc.x[k] = gen.RandomDouble();
			dist = c.NearestParticleDistance(loc) - Radius;
			if ((++count) >= MaxCount)
			{
				//std::cout << "Warning in FirstPassageTimeComputation : did not find a non-trapping initial place!\n";
				break;
			}
		} while (dist <= 0);
		if (count >= MaxCount) //did not find a starting point outside of the spheres
		{
			if(Verbosity >= 2)
				std::cout << "R too large, cannot find starting point!\n";
			return;
		}
		return FirstPassageTimeIteration(c, Radius, gen, Delta1, Delta2, Rmax, Tmax, MaxIteration, NTrial, loc, ReportFunction);
	}



	class BrownianMotionR2vsTComputation : public Computation
	{
	public:
		size_t SamplePerConfiguration;

		//the random walker is considered trapped when it comes to a trap closer than TrapDistanceCoeff*Radius
		//default is 1e-5;

		double Radius;

		std::vector<GeometryVector> result;

		//if the random walker comes to a trap closer than Delta1Coeff*Radius, a heterogeneous first-passage-time sphere
		//of radius Delta2Coeff*Radius is constructed
		//default is 1e-4 and 1e-2;
		double Delta1Coeff, Delta2Coeff;

		//if the first-passage-time sphere contains more than 1 traps, the volume fraction of the trap phase is found out by
		//Monte Carlo: NTrial random points are placed in the first-passage-time sphere, 
		size_t NTrial;
		double min, inc, max;

		BrownianMotionR2vsTComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter sample trajectories per configuration:";
			ifile >> SamplePerConfiguration;

			ofile << "Enter radius of spheres:";
			ifile >> Radius;

			Delta1Coeff = 1e-4;
			Delta2Coeff = 1e-2;
			NTrial = 1000;

			ofile << "Enter min, increment, and max time:";
			ifile >> min >> inc >> max;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			progress_display pd(NumConfig);

			struct data
			{
				double sum1, sumt, sumx2, sumx4;
				data() : sum1(0.0), sumt(0.0), sumx2(0.0), sumx4(0.0)
				{}
			};
			size_t NBins = std::ceil((max - min) / inc);
			std::vector<data> bins(NBins, data());
			double Tmax = min + NBins*inc;
#pragma omp parallel 
			{
				std::vector<data> mybins = bins;
#pragma omp for schedule(guided)
				for (long i = 0; i < NumConfig; i++)
				{
					RandomGenerator gen(i);
					Configuration c = GetConfigsFunction(i);
					DimensionType d = c.GetDimension();
					double typicalLength = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / d);
					c.SetCellSize(typicalLength);
					c.RefineCellList();

					for (size_t j = 0; j < SamplePerConfiguration; j++)
					{
						auto ReportFunction = [&](const GeometryVector & t) ->void
						{
							long i = (t.x[0] - min) / inc;
							if (i >= 0 && i < NBins)
							{
								mybins[i].sum1 += 1.0;
								mybins[i].sumt += t.x[0];
								mybins[i].sumx2 += t.x[1];
								mybins[i].sumx4 += t.x[1] * t.x[1];
							}
						};
						FirstPassageTimeIteration(c, Radius, gen, Delta1Coeff*Radius, Delta2Coeff*Radius, MaxDistance, Tmax, 1e9, 1e3, ReportFunction);

						//if (traj.size() > 0)
						//{
						//	for (int i = 0; i < NBins; i++)
						//	{
						//		double wantedT = min + i*inc;
						//		auto CompareFunc = [](const GeometryVector & left, const double & right) -> bool
						//		{
						//			return left.x[0] < right;
						//		};
						//		auto iter = std::lower_bound(traj.begin(), traj.end(), wantedT, CompareFunc);
						//		if (iter != traj.end())
						//		{
						//			mybins[i].sum1 += 1.0;
						//			mybins[i].sumt += iter->x[0];
						//			mybins[i].sumx2 += iter->x[1];
						//			mybins[i].sumx4 += iter->x[1] * iter->x[1];
						//		}
						//	}
						//}
					}


#pragma omp critical
					{
						pd++;
					}
				}

				for (long i = 0; i < NBins; i++)
				{
#pragma omp atomic
					bins[i].sum1 += mybins[i].sum1;
#pragma omp atomic
					bins[i].sumt += mybins[i].sumt;
#pragma omp atomic
					bins[i].sumx2 += mybins[i].sumx2;
#pragma omp atomic
					bins[i].sumx4 += mybins[i].sumx4;
				}
			}
			for (auto iter = bins.begin(); iter != bins.end(); ++iter)
			{
				if (iter->sum1 > 0)
				{
					double at = iter->sumt / iter->sum1;
					double ax2 = iter->sumx2 / iter->sum1;
					double ax4 = iter->sumx4 / iter->sum1;
					double stddev = ax4 - ax2*ax2;
					result.push_back(GeometryVector(at, ax2, 0.5*inc, stddev / std::sqrt(iter->sum1 - 1.0)));
				}
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_BrownianMotionR2vsT_R_" << Radius;
			logfile << "BrownianMotionR2vsT:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_BrownianMotionR2vsT_R_" << Radius;
			PlotFunction_Grace(result, ss.str(), "T", "R\\S2", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "Delta1Coeff")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> Delta1Coeff;
			else if (option == "Delta2Coeff")
				input >> Delta2Coeff;
			else if (option == "NTrial")
				input >> NTrial;
			else
				output << "Unrecognized command!\n";
		}
	};

	class EffectiveDiffusionCoefficientComputation : public Computation
	{
	public:
		size_t SamplePerConfiguration;

		//if the random walker comes to a trap closer than Delta1Coeff*Radius, a heterogeneous first-passage-time sphere
		//of radius Delta2Coeff*Radius is constructed
		//default is 1e-4 and 1e-2;
		double Delta1Coeff, Delta2Coeff;

		//if the random walker is Rmax away from its starting point, the random walk is ended
		//default is ::MaxDistance
		double Rmax;

		//if Tmax time has passed, the random walk is ended
		double Tmax;

		//if the first-passage-time sphere contains more than 1 traps, the volume fraction of the trap phase is found out by
		//Monte Carlo: NTrial random points are placed in the first-passage-time sphere, 
		size_t NTrial;

		std::vector<GeometryVector> result;

		EffectiveDiffusionCoefficientComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter sample trajectories per configuration:";
			ifile >> SamplePerConfiguration;

			ofile << "Min, increment, and max trap radius=";
			double min, inc, max;
			ifile >> min >> inc >> max;
			for (double r = min; r < max; r += inc)
				result.push_back(GeometryVector(r, 0.0, 0.0, 0.0));

			ofile << "Enter Tmax:";
			ifile >> Tmax;

			Delta1Coeff = 1e-4;
			Delta2Coeff = 1e-2;
			Rmax = ::MaxDistance;
			NTrial = 1000;
		}

		//this was an attempt to fit the brownian trajectory to <R^2>=c1*t+c2*(1-exp(-c3*t)).
		//while this formula works very well around the percolation threshold, it doesn't work well for small r
		//even a slight amount of noise could cause the second term to kick in, seriously reducing c1

		//static double ObjectiveFunction(unsigned n, const double* x, double* grad, void* f_data)
		//{
		//	std::vector<GeometryVector> * pBrownianTrajectory = (std::vector<GeometryVector> *) f_data;
		//	//assert(grad == nullptr);
		//	if (grad != nullptr)
		//	{
		//		grad[0] = 0;
		//		grad[1] = 0;
		//		grad[2] = 0;
		//	}
		//	double result = 0;
		//	for (auto iter = pBrownianTrajectory->begin(); iter != pBrownianTrajectory->end(); ++iter)
		//	{
		//		double t = iter->x[0];
		//		double delta = x[0] * t + x[1] * (1 - std::exp((-1.0)*x[2] * t)) - iter->x[1];
		//		result += delta*delta;
		//		if (grad != nullptr)
		//		{
		//			grad[0] += 2 * delta * t;
		//			grad[1] += 2 * delta*(1 - std::exp((-1.0)*x[2] * t));
		//			grad[2] += 2 * delta*x[1] * std::exp((-1.0)*x[2] * t)*t;
		//		}
		//	}
		//	//debug temp
		//	std::cout << x[0] << " \t" << x[1] << " \t" << x[2] << " \t" << result << '\n';

		//	return result;
		//}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			progress_display pd(result.size());
			size_t tempVerbosity = 0;
			std::swap(Verbosity, tempVerbosity);

			if (NumConfig == 0) return;

			DimensionType d = GetConfigsFunction(0).GetDimension();

			//see above commented function
			//std::vector<double> x(3, 0.0), lb(3, 0.0), ub(3, 0.0);
			//x[0] = 2 * d;
			//x[1] = 1;
			//x[2] = 0.02;
			//lb[0] = 0;
			//lb[1] = 0;
			//lb[2] = 0;
			//ub[0] = 2 * d + 2;
			//ub[1] = 100;
			//ub[2] = 1;

			for (int i = 0; i < result.size(); i++)
			{

				if (result[i].x[0] > 0)
				{
					std::stringstream fakeInput, fakeOutput;
					fakeInput << SamplePerConfiguration << " \t" << result[i].x[0] << " \t" << 0.01*Tmax << " \t" << 0.01*Tmax << " \t" << Tmax;
					BrownianMotionR2vsTComputation compute(fakeInput, fakeOutput);
					compute.Delta1Coeff = this->Delta1Coeff;
					compute.Delta2Coeff = this->Delta2Coeff;
					compute.NTrial = this->NTrial;
					compute.Compute(GetConfigsFunction, NumConfig);

					std::vector<GeometryVector> data[2];
					data[0] = compute.result;

					//see above commented function
					//std::vector<GeometryVector> * pBrownianTrajectory = &data[0];

					//nlopt::opt opt(nlopt::algorithm::LD_LBFGS, 3);
					//opt.set_min_objective(ObjectiveFunction, (void *)(pBrownianTrajectory));
					//opt.set_ftol_rel(1e-10);
					//opt.set_initial_step(1e-3);
					//opt.set_lower_bounds(lb);
					//opt.set_upper_bounds(ub);
					//x[2] = std::max(x[2], 0.01);
					//x = opt.optimize(x);
					//x[2] = std::max(x[2], 0.01);
					//x = opt.optimize(x);
					////debug temp
					//std::cout << "optimization finish. c_0=" << x[0] << ", c_1=" << x[1] << ", c_2=" << x[2] << '\n';

					//new idea: just do a linear fit for the last 60% of the Brownian trajectory
					std::vector<double> yy;
					std::vector< std::vector<double> > xx(2, std::vector<double>());
					for (auto iter = data[0].begin(); iter != data[0].end(); ++iter)
					{
						if (iter->x[0] > 0.4*Tmax)
						{
							xx[0].push_back(1.0);
							xx[1].push_back(iter->x[0]);
							yy.push_back(iter->x[1]);
						}
					}
					std::vector < double> c = MultiVariableLinearFit(yy, xx);

					for (int i = 0; i < data[0].size(); i++)
					{
						double t = data[0][i].x[0];
						data[1].push_back(GeometryVector(t, c[0]+c[1]*t));
					}
					std::vector<std::string> legends;
					legends.push_back("simulation");
					legends.push_back("fit");
					std::stringstream ss;
					ss << "BrownianMotionR2vsT_R_" << result[i].x[0];
					PlotFunction_Grace(data, 2, ss.str(), "T", "R\\S2", legends, "");

					result[i].x[1] = c[1]/(2*d);
				}
				else
					result[i].x[1] = 0;

				pd++;
			}
			std::swap(Verbosity, tempVerbosity);
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_EffectiveDiffusionCoefficient";
			logfile << "EffectiveDiffusionCoefficient:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_EffectiveDiffusionCoefficient";
			PlotFunction_Grace(result, ss.str(), "a", "D\\se\\N(a)", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "Delta1Coeff")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> Delta1Coeff;
			else if (option == "Delta2Coeff")
				input >> Delta2Coeff;
			else if (option == "NTrial")
				input >> NTrial;
			else if (option == "Rmax")
				input >> Rmax;
			else
				output << "Unrecognized command!\n";
		}
	};


	//old implementation, not great because the effective conductivity is calculated as <R^2>/2dT.
	//however, even if its not percolating, R^2 is still a finite small number, leading to a positive calculated effective conductivity
//	class EffectiveConductivityComputation : public Computation
//	{
//	public:
//		size_t SamplePerConfiguration;
//
//		//if the random walker comes to a trap closer than Delta1Coeff*Radius, a heterogeneous first-passage-time sphere
//		//of radius Delta2Coeff*Radius is constructed
//		//default is 1e-4 and 1e-2;
//		double Delta1Coeff, Delta2Coeff;
//
//		//if the random walker is Rmax away from its starting point, the random walk is ended
//		//default is ::MaxDistance
//		double Rmax;
//
//		//if Tmax time has passed, the random walk is ended
//		double Tmax;
//
//		//if the first-passage-time sphere contains more than 1 traps, the volume fraction of the trap phase is found out by
//		//Monte Carlo: NTrial random points are placed in the first-passage-time sphere, 
//		size_t NTrial;
//
//		std::vector<GeometryVector> result;
//
//		EffectiveConductivityComputation(std::istream & ifile, std::ostream & ofile)
//		{
//			ofile << "Enter sample trajectories per configuration:";
//			ifile >> SamplePerConfiguration;
//
//			ofile << "Min, increment, and max trap radius=";
//			double min, inc, max;
//			ifile >> min >> inc >> max;
//			for (double r = min; r < max; r += inc)
//				result.push_back(GeometryVector(r, 0.0, 0.0, 0.0));
//
//			ofile << "Enter Tmax:";
//			ifile >> Tmax;
//
//			Delta1Coeff = 1e-4;
//			Delta2Coeff = 1e-2;
//			Rmax = ::MaxDistance;
//			NTrial = 1000;
//		}
//		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
//		{
//			progress_display pd(NumConfig);
//			std::vector<double> sumt2(result.size(), 0.0);
//			std::vector<double> sumt(result.size(), 0.0);
//			std::vector<double> sumtathalf(result.size(), 0.0);
//			std::vector<double> sum1(result.size(), 0.0);
//
//#pragma omp parallel 
//			{
//#pragma omp for schedule(guided)
//				for (long i = 0; i < NumConfig; i++)
//				{
//					RandomGenerator gen(i);
//					Configuration c = GetConfigsFunction(i);
//					DimensionType d = c.GetDimension();
//					double typicalLength = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / d);
//					c.SetCellSize(1.0*typicalLength);
//					c.RefineCellList();
//
//					// computations
//					//loop over all radii
//					for (size_t m = 0; m < result.size(); m++)
//					{
//						double Radius = result[m].x[0];
//						double t;
//						double thalf;
//
//						if (Radius > 0)
//						{
//							GeometryVector loc(c.GetDimension());
//							for (DimensionType k = 0; k < d; k++)
//								loc.x[k] = gen.RandomDouble();
//
//							std::vector<GeometryVector> data = FirstPassageTimeIteration(c, Radius, gen, Delta1Coeff*Radius, Delta2Coeff*Radius, Rmax, Tmax, 1e7, NTrial, loc);
//
//							if (data.size() > 0)
//							{
//								size_t n = data.size() - 1;
//								t = data[n].x[1] / (2.0*d*data[n].x[0]);
//								thalf = data[n / 2].x[1] / (2.0*d*data[n / 2].x[0]);
//							}
//							else
//							{
//								//particle already in the non-conducting phase
//								t = 0;
//								thalf = 0;
//							}
//						}
//						else
//						{
//							//there is no trapping phase at all
//							t = 1.0;
//							thalf = 1.0;
//						}
//
//#pragma omp atomic
//							sum1[m] += 1.0;
//#pragma omp atomic
//							sumt[m] += t;
//#pragma omp atomic
//							sumt2[m] += t*t;
//#pragma omp atomic
//							sumtathalf[m] += thalf;
//					}
//#pragma omp critical
//					{
//						pd++;
//					}
//				}
//			}
//
//			std::vector<GeometryVector> temp;
//			bool Warned = false;
//			for (size_t m = 0; m < result.size(); m++)
//			{
//				if (sum1[m]>0.5)
//				{
//					//average time
//					result[m].x[1] = sumt[m] / sum1[m];
//					//radius uncertainty
//					result[m].x[2] = 0.0;
//					//time uncertainty
//					result[m].x[3] = std::sqrt((sumt2[m] / sum1[m] - result[m].x[1] * result[m].x[1]) / (sum1[m] - 1.0));
//
//					temp.push_back(result[m]);
//
//					if (std::abs( (sumtathalf[m] / sum1[m]) - result[m].x[1] ) > 3.0*result[m].x[3] && !Warned)
//					{
//						std::cout << "Warning in EffectiveConductivityComputation : displacement squared appears non-linear with time. Trapping possible. R=" << result[m].x[0] << '\n';
//						Warned = true;
//					}
//				}
//			}
//			std::swap(result, temp);
//		}
//		virtual void Write(const std::string OutputPrefix)
//		{
//			std::stringstream ss;
//			ss << OutputPrefix << "_EffectiveConductivity";
//			logfile << "EffectiveConductivity:\n";
//			WriteFunction(result, logfile);
//			WriteFunction(result, ss.str());
//		}
//		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
//		{
//			std::stringstream ss;
//			ss << OutputPrefix << "_EffectiveConductivity";
//			PlotFunction_Grace(result, ss.str(), "R", "\\xs\\f{}(R)", Title);
//		}
//		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
//		{
//			if (option == "Delta1Coeff")
//				//default=1, set>1 to get better x resolution, <1 to get better y resolution
//				input >> Delta1Coeff;
//			else if (option == "Delta2Coeff")
//				input >> Delta2Coeff;
//			else if (option == "NTrial")
//				input >> NTrial;
//			else if (option == "Rmax")
//				input >> Rmax;
//			else
//				output << "Unrecognized command!\n";
//		}
//	};


	//calculate mean survival time using first-passage time technique
	//set difussion coefficient D=1
	class SurvivalTimeDistributionComputation : public Computation
	{
	public:
		size_t SamplePerConfiguration;
		size_t SamplePerTrajectory;

		//the random walker is considered trapped when it comes to a trap closer than TrapDistanceCoeff*Radius
		//default is 1e-5;
		double TrapDistanceCoeff;

		double Radius;

		double ResolutionPreference;

		std::vector<GeometryVector> result;

		SurvivalTimeDistributionComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter sample trajectories per configuration:";
			ifile >> SamplePerConfiguration;
			ofile << "Enter sample survival times per trajectory:";
			ifile >> SamplePerTrajectory;

			ofile << "Enter radius of spheres:";
			ifile >> Radius;

			TrapDistanceCoeff = 1e-5;
			ResolutionPreference = 1.0;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			progress_display pd(NumConfig);
			std::vector<double> Times(NumConfig*SamplePerConfiguration*SamplePerTrajectory, 0.0);
#pragma omp parallel 
			{
#pragma omp for schedule(guided)
				for (long i = 0; i < NumConfig; i++)
				{
					RandomGenerator gen(i);
					Configuration c = GetConfigsFunction(i);
					DimensionType d = c.GetDimension();
					double typicalLength = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / d);
					c.SetCellSize(typicalLength);
					c.RefineCellList();

					double TrapDistance = TrapDistanceCoeff*Radius;
					for (long j = 0; j < SamplePerConfiguration; j++)
					{
						//Generate a random point
						GeometryVector loc = GeometryVector(d);
						double dist = 0;//distance from the location to the nearest trap

						size_t count = 0;
						do
						{
							for (DimensionType k = 0; k < d; k++)
								loc.x[k] = gen.RandomDouble();
							dist = c.NearestParticleDistance(loc) - Radius;
							if (count++ > 10000000)
							{
								std::cout << "Error in SurvivalTimeDistributionComputation : did not find a non-trapping initial place!\n";
								break;
							}
						} while (dist <= 0);

						//first passage time iteration
						while (dist > TrapDistance)
						{
							//time += dist*dist / (2.0*d);
							for (int k = 0; k < SamplePerTrajectory; k++)
								Times[i*SamplePerConfiguration*SamplePerTrajectory + j*SamplePerTrajectory + k] += dist*dist*FirstPassageTime::findT(gen.RandomDouble(), d);

							//move the location
							loc = c.RelativeCoord2CartesianCoord(loc);
							GeometryVector RandomDirection(d);
							GetRandomVector(d, gen, RandomDirection.x);
							loc.AddFrom(dist*RandomDirection);
							loc = c.CartesianCoord2RelativeCoord(loc);

							//calculate distance to nearest trap
							dist = c.NearestParticleDistance(loc) - Radius;

							//safety test
							if (dist < -1e-10)
							{
								std::cout << "Error in first passage time computation: particle entered the trapping phase! dist=" << dist << '\n';
							}
						}
					}
#pragma omp critical
					{
						pd++;
					}
				}
			}
			HistogramGenerator hgen;
			hgen.GenerateBins(Times, 1.0, ResolutionPreference);
			std::vector<GeometryVector> temp;
			HistogramToPDF(hgen, temp);

			this->result.push_back(GeometryVector(0.0, 0.0));
			for (auto iter = temp.begin(); iter != temp.end(); ++iter)
			{
				if (iter->x[0]>0.0)
					this->result.push_back(*iter);
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_SurvivalTimeDistribution_R_"<<Radius;
			logfile << "SurvivalTimeDistribution:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_SurvivalTimeDistribution_R_" << Radius;
			PlotFunction_Grace(result, ss.str(), "\\xt", "P(\\xt\\f{})", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "ResolutionPreference")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> ResolutionPreference;
			else if (option == "TrapDistanceCoeff")
				input >> TrapDistanceCoeff;
			else
				output << "Unrecognized command!\n";
		}
	};

	class SurvivalFractionComputation : public Computation
	{
	public:
		size_t SamplePerConfiguration;
		size_t SamplePerTrajectory;

		//the random walker is considered trapped when it comes to a trap closer than TrapDistanceCoeff*Radius
		//default is 1e-5;
		double TrapDistanceCoeff;

		double Radius;

		double ResolutionPreference;

		std::vector<GeometryVector> result;

		bool SpecifyEv;//the user had specified Ev 
		double DesiredEv;

		SurvivalFractionComputation(std::istream & ifile, std::ostream & ofile)
		{
			ofile << "Enter sample trajectories per configuration:";
			ifile >> SamplePerConfiguration;
			ofile << "Enter sample survival times per trajectory:";
			ifile >> SamplePerTrajectory;

			ofile << "Enter radius of spheres:";
			ifile >> Radius;

			TrapDistanceCoeff = 1e-5;
			ResolutionPreference = 1.0;

			SpecifyEv = false;
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			result.clear();
			progress_display pd(NumConfig);
			std::vector<double> Times(NumConfig*SamplePerConfiguration*SamplePerTrajectory, 0.0);
#pragma omp parallel 
			{
#pragma omp for schedule(guided)
				for (long i = 0; i < NumConfig; i++)
				{
					RandomGenerator gen(i);
					Configuration c = GetConfigsFunction(i);
					DimensionType d = c.GetDimension();
					double typicalLength = std::pow(c.PeriodicVolume() / c.NumParticle(), 1.0 / d);
					c.SetCellSize(typicalLength);
					c.RefineCellList();

					double TrapDistance = TrapDistanceCoeff*Radius;
					for (long j = 0; j < SamplePerConfiguration; j++)
					{
						//Generate a random point
						GeometryVector loc = GeometryVector(d);
						double dist = 0;//distance from the location to the nearest trap

						size_t count = 0;
						do
						{
							for (DimensionType k = 0; k < d; k++)
								loc.x[k] = gen.RandomDouble();
							dist = c.NearestParticleDistance(loc) - Radius;
							if (count++ > 10000000)
							{
								std::cout << "Error in SurvivalFractionComputation : did not find a non-trapping initial place!\n";
								break;
							}
						} while (dist <= 0);

						//first passage time iteration
						while (dist > TrapDistance)
						{
							//time += dist*dist / (2.0*d);
							for (int k = 0; k < SamplePerTrajectory; k++)
								Times[i*SamplePerConfiguration*SamplePerTrajectory + j*SamplePerTrajectory + k] += dist*dist*FirstPassageTime::findT(gen.RandomDouble(), d);

							//move the location
							loc = c.RelativeCoord2CartesianCoord(loc);
							GeometryVector RandomDirection(d);
							GetRandomVector(d, gen, RandomDirection.x);
							loc.AddFrom(dist*RandomDirection);
							loc = c.CartesianCoord2RelativeCoord(loc);

							//calculate distance to nearest trap
							dist = c.NearestParticleDistance(loc) - Radius;

							//safety test
							if (dist < -1e-10)
							{
								std::cout << "Error in SurvivalFractionComputation: particle entered the trapping phase! dist=" << dist << '\n';
							}
						}
					}
#pragma omp critical
					{
						pd++;
					}
				}
			}
			HistogramGenerator hgen;
			hgen.GenerateBins(Times, 1.0, ResolutionPreference);
			std::vector<GeometryVector> temp;
			HistogramToCDF(hgen, temp);

			this->result.push_back(GeometryVector(0.0, 1.0, 0.0, 0.0));
			for (auto iter = temp.begin(); iter != temp.end(); ++iter)
			{
				if (iter->x[0]>0.0)
				{
					GeometryVector temp = *iter;
					temp.x[1] = 1.0 - temp.x[1];
					this->result.push_back(temp);
				}
			}
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			if (SpecifyEv)
				ss << OutputPrefix << "_SurvivalFraction_Ev_" << DesiredEv;
			else
				ss << OutputPrefix << "_SurvivalFraction_R_" << Radius;
			logfile << "SurvivalFraction:\n";
			WriteFunction(result, logfile);
			WriteFunction(result, ss.str());
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
			std::stringstream ss;
			if (SpecifyEv)
				ss << OutputPrefix << "_SurvivalFraction_Ev_" << DesiredEv;
			else
				ss << OutputPrefix << "_SurvivalFraction_R_" << Radius;
			PlotFunction_Grace(result, ss.str(), "\\xt", "P(\\xt\\f{})", Title);
		}
		virtual void ProcessAdditionalOption(const std::string & option, std::istream & input, std::ostream & output)
		{
			if (option == "ResolutionPreference")
				//default=1, set>1 to get better x resolution, <1 to get better y resolution
				input >> ResolutionPreference;
			else if (option == "TrapDistanceCoeff")
				input >> TrapDistanceCoeff;
			else if (option == "SpecifyEv")
			{
				//find a radius a that produces the desired Ev
				//must already have Ev computed
				std::cout << "desired Ev=";
				std::cin >> DesiredEv;
				std::cout << "prefix for Ev:";
				std::string prefix;
				std::cin >> prefix;
				Radius = InterpolateEv(prefix + "_Ev", DesiredEv);

				std::cout << "set radius to " << Radius << '\n';

				SpecifyEv = true;
			}
			else
				output << "Unrecognized command!\n";
		}
	};

	class ThreeBodyCorrelationComputation : public Computation
	{
	public:
		double Rmax;
		size_t NBins;
		double ThetaMin, ThetaMax;
		std::vector<double> g3;

		ThreeBodyCorrelationComputation(std::istream & ifile, std::ostream & ofile)
		{
			std::cout << "Rmax=";
			std::cin >> Rmax;
			std::cout << "Number of bins per distance (total number of bins is this number squared) =";
			std::cin >> NBins;
			std::cout << "Min and Max of theta (the angle between the two neighbors) (from 0 to pi) =";
			std::cin >> ThetaMin >> ThetaMax;
			ThetaMin = std::max(ThetaMin, 0.0);
			ThetaMax = std::min(::pi, ThetaMax);
			g3 = std::vector<double>(NBins*NBins, 0.0);
		}
		virtual void Compute(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfig)
		{
			progress_display pd(NumConfig);
			double sumrho2 = 0.0, sumN = 0.0;
#pragma omp parallel for schedule(guided)
			for (int i = 0; i < NumConfig; i++)
			{
				Configuration c = GetConfigsFunction(i);
				size_t N = c.NumParticle();
				for (size_t j = 0; j < N; j++)
				{
					std::vector<GeometryVector> neighbors;
					auto IterateFunc = [&](const GeometryVector & shift, const GeometryVector & LatticeShift, const signed long * PeriodicShift, const size_t Sourceparticle) -> void
					{
						if (Sourceparticle != j)
							neighbors.push_back(shift);
					};
					c.IterateThroughNeighbors(j, Rmax, IterateFunc);

					for(auto iter1=neighbors.begin(); iter1!=neighbors.end(); ++iter1)
						for(auto iter2=iter1+1; iter2!=neighbors.end(); ++iter2)
						{
							GeometryVector r12 = *iter1;
							GeometryVector r23 = *iter2;
							double l12 = std::sqrt(r12.Modulus2());
							double l23 = std::sqrt(r23.Modulus2());
							double Angle = std::acos((1-1e-14)*r12.Dot(r23) / l12 / l23);

							//std::cout << Angle << '\n';

							if (Angle > ThetaMin && Angle < ThetaMax)
							{
								if (l12 > l23) std::swap(l12, l23);
								size_t N1 = std::floor(l12 / Rmax*NBins);
								size_t N2 = std::floor(l23 / Rmax*NBins);

								#pragma omp atomic
								g3[N1*NBins + N2] += 1.0;
							}
						}
				}

				double rho2 = (c.NumParticle()-1)*(c.NumParticle()-2) / c.PeriodicVolume()/c.PeriodicVolume();
#pragma omp critical (OneDThreeBodyCorrelationComputation)
				{
					sumrho2 += rho2;
					sumN += N;
					pd++;
				}
			}
			DimensionType d = GetConfigsFunction(0).GetDimension();

			//normalize g3
			double averageRho2 = sumrho2 / NumConfig;
			double factor = averageRho2*sumN*Rmax*Rmax / (NBins*NBins);
			for(size_t i=0; i<NBins; i++)
				for (size_t j = i; j < NBins; j++)
				{
					double AngularFactor = 0.0;
					if (d == 1)
						AngularFactor = 1.0;
					else
					{
						const size_t Integral_Steps = 100;
						AngularFactor += 0.5*(HyperSphere_SurfaceArea(d-1, std::sin(ThetaMin))+HyperSphere_SurfaceArea(d-1, std::sin(ThetaMax)));
						for (size_t i = 1; i < Integral_Steps; i++)
							AngularFactor += HyperSphere_SurfaceArea(d - 1, std::sin(ThetaMin + (ThetaMax - ThetaMin)*i / Integral_Steps));
						AngularFactor *= (ThetaMax - ThetaMin) / Integral_Steps;// d theta
						double r12 = (i+0.5)*Rmax / NBins;
						double r23 = (j+0.5)*Rmax / NBins;
						AngularFactor *= 0.5*std::pow(r12*r23, d-1)*HyperSphere_SurfaceArea(d, 1.0);
					}
					if(i!=j)
						g3[i*NBins + j] /= (2.0*factor*AngularFactor);
					else
						g3[i*NBins + j] /= (factor*AngularFactor);
				}
			//for(size_t i=0; i<NBins; i++)
			//	g3[i*NBins + i] /= factor;

			for (size_t i = 1; i < NBins; i++)
				for (size_t j = 0; j < i; j++)
					g3[i*NBins + j] = g3[j*NBins + i];
		}
		virtual void Write(const std::string OutputPrefix)
		{
			std::stringstream ss;
			ss << OutputPrefix << "_ThetaMin_" << ThetaMin << "_ThetaMax_" << ThetaMax;
			std::fstream ofile(ss.str() + std::string("_g3.txt"), std::fstream::out);
			std::fstream ofilex(ss.str() + std::string("_g3_x.txt"), std::fstream::out);
			std::fstream ofiley(ss.str() + std::string("_g3_y.txt"), std::fstream::out);
			std::fstream ofilez(ss.str() + std::string("_g3_z.txt"), std::fstream::out);
			for (size_t i = 0; i < NBins; i++)
			{
				for (size_t j = 0; j < NBins; j++)
				{
					ofile << (0.5 + i)*Rmax / NBins << " " << (0.5 + j)*Rmax / NBins << " " << g3[i*NBins + j] << '\n';
					ofilex << (0.5 + i)*Rmax / NBins << " \t";
					ofiley << (0.5 + j)*Rmax / NBins << " \t";
					ofilez << g3[i*NBins + j] << " \t";
				}
				ofilex << std::endl;
				ofiley << std::endl;
				ofilez << std::endl;
			}
		}
		virtual void Plot(const std::string OutputPrefix, const std::string & Title)
		{
		}
	};

};

int PairStatisticsCLI()
{
	int PairStatisticsDebug();

	char tempstring[1000];
	std::istream & ifile=std::cin;
	std::ostream & ofile=std::cout;
	double Rescale=1.0;
	size_t NumConfig =0;
	std::string OutputPrefix;
	std::string GraceTitle;
	std::function<const Configuration(size_t i)> GetConfigsFunction;	
	std::vector<Computation *> vpComputations;
	for(;;)
	{
		ifile>>tempstring;
		if(strcmp(tempstring, "Exit")==0)
		{
			for(auto iter=vpComputations.begin(); iter!=vpComputations.end(); iter++)
				delete *iter;
			return 0;
		}
		if(strcmp(tempstring, "Debug")==0)
		{
			PairStatisticsDebug();
		}
		else if(strcmp(tempstring, "GraceTitle")==0)
		{
			ifile>>GraceTitle;
		}
		else if(strcmp(tempstring, "OutputPrefix")==0)
		{
			ifile>>OutputPrefix;
		}
		else if(strcmp(tempstring, "AlsoWriteEPS")==0)
		{
			ifile>>AlsoWriteEPS;
		}
		else if(strcmp(tempstring, "Rescale")==0)
		{
			std::cerr << "Warning : Rescale is deprecated\n";
			ifile>>Rescale;
		}
		else if(strcmp(tempstring, "NumConfig")==0)
		{
			ifile>>NumConfig;
		}
		else if(strcmp(tempstring, "g2Computation")==0)
		{
			vpComputations.push_back( new g2Computation(ifile, ofile) );
		}
		else if(strcmp(tempstring, "Directionalg2Computation")==0)
		{
			vpComputations.push_back( new Directionalg2Computation(ifile, ofile) );
		}
		else if (strcmp(tempstring, "SkComputation") == 0)
		{
			vpComputations.push_back(new SkComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "NearestNeighborComputation") == 0)
		{//for historical reasons
			vpComputations.push_back( new HpComputation(ifile, ofile) );
		}
		else if(strcmp(tempstring, "HpComputation")==0)
		{
			vpComputations.push_back( new HpComputation(ifile, ofile) );
		}
		else if(strcmp(tempstring, "HvComputation")==0)
		{
			vpComputations.push_back( new HvComputation(ifile, ofile) );
		}
		else if (strcmp(tempstring, "VoronoiVolumeComputation") == 0)
		{
			vpComputations.push_back(new VoronoiVolumeComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "VoronoiNumSidesComputation") == 0)
		{
			vpComputations.push_back(new VoronoiNumSidesComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "CoveringRadiusDistributionComputation") == 0)
		{
			vpComputations.push_back(new CoveringRadiusDistributionComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "PackingRadiusDistributionComputation") == 0)
		{
			vpComputations.push_back(new PackingRadiusDistributionComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "AverageClusterSizeComputation") == 0)
		{
			vpComputations.push_back(new AverageClusterSizeComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "VoronoiVolumeCorrelationComputation") == 0)
		{
			vpComputations.push_back(new VoronoiVolumeCorrelationComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "Psi6CorrelationComputation") == 0)
		{
			vpComputations.push_back(new Psi6CorrelationComputation(ifile, ofile) );
		}
		else if (strcmp(tempstring, "LocalQ6DistributionComputation") == 0)
		{
			vpComputations.push_back(new LocalQ6DistributionComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "WindowNumberVarianceComputation") == 0)
		{
			vpComputations.push_back(new WindowNumberVarianceComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "AnalyticWindowNumberVarianceComputation") == 0)
		{
			vpComputations.push_back(new AnalyticWindowNumberVarianceComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "WindowNumberDistributionComputation") == 0)
		{
			vpComputations.push_back( new WindowNumberDistributionComputation(ifile, ofile) );
		}
		else if(strcmp(tempstring, "NeighborLinkTortuosityComputation")==0)
		{
			vpComputations.push_back( new NeighborLinkTortuosityComputation(ifile, ofile) );
		}
		else if (strcmp(tempstring, "VarianceOverRd_1Computation") == 0)
		{
			vpComputations.push_back(new VarianceOverRd_1Computation(ifile, ofile));
		}
		else if (strcmp(tempstring, "PercolationVolumeFractionDistribution") == 0)
		{
			vpComputations.push_back(new PercolationVolumeFractionDistribution(ifile, ofile));
		}
		else if (strcmp(tempstring, "PercolationP1Computation") == 0)
		{
			vpComputations.push_back(new PercolationP1Calculation(ifile, ofile));
		}
		else if (strcmp(tempstring, "PercolationP1") == 0)
		{
			vpComputations.push_back(new PercolationP1Calculation_v2(ifile, ofile));
		}
		else if (strcmp(tempstring, "PercolationP1Computation_v2") == 0)
		{
			vpComputations.push_back(new PercolationP1Calculation_v2(ifile, ofile));
		}
		else if (strcmp(tempstring, "PercolationP1Calculation") == 0)
		{
			vpComputations.push_back(new PercolationP1Calculation(ifile, ofile));
		}
		else if (strcmp(tempstring, "M2Computation") == 0)
		{
			vpComputations.push_back(new M2Computation(ifile, ofile));
		}
		else if (strcmp(tempstring, "VoidPhaseM2Computation") == 0)
		{
			vpComputations.push_back(new VoidPhaseM2Computation(ifile, ofile));
		}
		else if (strcmp(tempstring, "VoidPhasePercolationDiameterDistribution") == 0)
		{
			vpComputations.push_back(new VoidPhasePercolationDiameterDistribution(ifile, ofile));
		}
		else if (strcmp(tempstring, "DiscretizationVolumeFractionComputation") == 0)
		{
			vpComputations.push_back(new DiscretizationVolumeFractionComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "MeanSurvivalTimeComputation") == 0)
		{
			vpComputations.push_back(new MeanSurvivalTimeComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "FirstPassageTimeComputation") == 0)
		{
			vpComputations.push_back(new MeanSurvivalTimeComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "BrownianMotionR2vsTComputation") == 0)
		{
			vpComputations.push_back(new BrownianMotionR2vsTComputation(ifile, ofile));
		}
		//else if (strcmp(tempstring, "EffectiveConductivityComputation") == 0)
		//{
		//	vpComputations.push_back(new EffectiveConductivityComputation(ifile, ofile));
		//}
		else if (strcmp(tempstring, "EffectiveDiffusionCoefficientComputation") == 0)
		{
			vpComputations.push_back(new EffectiveDiffusionCoefficientComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "SurvivalTimeDistributionComputation") == 0)
		{
			vpComputations.push_back(new SurvivalTimeDistributionComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "SurvivalFractionComputation") == 0)
		{
			vpComputations.push_back(new SurvivalFractionComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "ThreeBodyCorrelationComputation") == 0)
		{
			vpComputations.push_back(new ThreeBodyCorrelationComputation(ifile, ofile));
		}
		else if (strcmp(tempstring, "GetConfigsFunction") == 0)
		{
			ofile<<"Input Type:";
			ifile>>tempstring;
			if(strcmp(tempstring, "PrefixNumberSuffix")==0)
			{
				PrefixNumberSuffix c(ifile, ofile, Rescale);
				GetConfigsFunction = c;
			}
			else if (strcmp(tempstring, "readTfEnsembleCCOutput") == 0)
			{
				readTfEnsembleCCOutput c(ifile, ofile);
				GetConfigsFunction = c;
			}
			else if (strcmp(tempstring, "ReadConfigPack") == 0)
			{
				ReadConfigPack c(ifile, ofile, Rescale);
				GetConfigsFunction = c;
				//automatic sets NumConfig since Configuration Pack contains this information
				NumConfig = c.p.NumConfig();
				std::cout << "The config pack contains " << NumConfig << " configurations, set NumConfig to this value.\n";
			}
			else if (strcmp(tempstring, "SampleConfigPack") == 0)
			{
				SampleConfigPack c(ifile, ofile, Rescale);
				GetConfigsFunction = c;
			}
			else if (strcmp(tempstring, "ReadConfigPack_withInitialNumber") == 0)
			{
				ReadConfigPack_withInitialNumber c(ifile, ofile, Rescale);
				GetConfigsFunction = c;
				//automatic sets NumConfig since Configuration Pack contains this information
				NumConfig = c.p.NumConfig() - c.InitialNumber;
				std::cout << "The config pack contains " << c.p.NumConfig() << " configurations, set NumConfig to " << NumConfig << "\n";
			}
			else if (strcmp(tempstring, "SingleConfiguration") == 0)
			{
				std::string prefix;
				ofile << "Input prefix:";
				ifile >> prefix;
				SingleConfiguration c(ReadPos(prefix));
				GetConfigsFunction = c;
				//automatic sets NumConfig 
				NumConfig = 1;
				std::cout << "set NumConfig to " << 1 << "\n";
			}
			else
			{
				std::cout<<"Unrecognized Type!\n";
				std::cin.clear();
			}
		}
		else if (strcmp(tempstring, "RescaleToUnitDensity") == 0)
		{
			if (!GetConfigsFunction)
				std::cerr << "Specify GetConfigsFunction before specifying rescaling!\n";
			else
			{
				RescaleToUnitDensity c(GetConfigsFunction);
				GetConfigsFunction = c;
			}
		}
		else if(strcmp(tempstring, "Calculation")==0)
		{
			if(!GetConfigsFunction)
				std::cerr<<"Specify GetConfigsFunction before compute!\n";
			else
			{
				for(auto iter=vpComputations.begin(); iter!=vpComputations.end(); iter++)
				{
					(*iter)->Compute(GetConfigsFunction, NumConfig);
					(*iter)->Write(OutputPrefix);
					(*iter)->Plot(OutputPrefix, GraceTitle);
				}
			}
		}
		//else if(strcmp(tempstring, "AngularStructureFactor")==0)
		//{
		//	std::cout<<"KMax=";
		//	double KMax;
		//	std::cin>>KMax;
		//	AngularStructureFactor(GetConfigsFunction, NumConfig, KMax);
		//}
		else
		{
			if (vpComputations.empty())
				std::cout << "Unrecognized command!\n";
			else
				vpComputations.back()->ProcessAdditionalOption(tempstring, std::cin, std::cout);

			std::cin.clear();
		}
		ifile.ignore(1000,'\n');
		if(ifile.eof()) return 2;
	}
	return 1;
}

#include "RandomSequentialAddition.h"
SpherePacking DoRSA(const SpherePacking & pa, double radius)
{
	RSA con1(pa, radius);
	con1.RSA_I(4, 500);

	con1.GetVoxelList(0.49);
	int SplitCount=0;
	while(con1.pVoxels->NumVoxel()!=0)
	{
		con1.RSA_II(4, 500, false);

		unsigned long temp=con1.pVoxels->NumVoxel();
		con1.SplitVoxel(false, 1);
		double ratio=static_cast<double>(con1.pVoxels->NumVoxel())/temp;
	}
	return SpherePacking(*con1.pSpheres);
}
bool IsSaturated(const SpherePacking & pa, double radius)
{
	RSA con1(pa, radius);
	con1.RSA_I(4, 500);
	if(con1.pSpheres->NumParticle() > pa.NumParticle())
		return false;

	con1.GetVoxelList(0.49);
	int SplitCount=0;
	while(con1.pVoxels->NumVoxel()!=0)
	{
		con1.RSA_II(4, 500, false);
		if(con1.pSpheres->NumParticle() > pa.NumParticle())
			return false;

		unsigned long temp=con1.pVoxels->NumVoxel();
		con1.SplitVoxel(false, 1);
		double ratio=static_cast<double>(con1.pVoxels->NumVoxel())/temp;
	}
	return true;
}

#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_sf_bessel.h>
#include "Solvers.h"


class RecSqrt3Potential : public IsotropicPairPotential
{
public:
	RecSqrt3Potential() : IsotropicPairPotential(2, 5.9273268136783)
	{
	}
	virtual double IsotropicEnergyFormula(double r)
	{
		return (std::pow(1.385640648/r, 12)-1.7470948473378+1.5860359473738*r)*(8.2648240165932-r)*(8.2648240165932-r)*std::exp(-0.64871881695668*r*r);
	}
};

int SpinOrderMetric()
{
	int lx, ly;
	std::cout<<"L_x=";
	std::cin>>lx;
	std::cout<<"L_y=";
	std::cin>>ly;
	std::cout<<"Configuration=";
	std::fstream ifile("106x146.in", std::fstream::in);
	ifile.ignore(10000, '\n');
	ifile.ignore(10000, '\n');
	ifile.ignore(10000, ' ');
	GeometryVector bas[2]={GeometryVector(1, 0), GeometryVector(0, 1)};
	Configuration cc(2, bas, 1.0);
	for(int i=0; i<lx; i++)
		for(int j=0; j<ly; j++)
		{
			char c;
			ifile>>c;
			if(c=='+')
				cc.Insert("A", GeometryVector((double)(i)/lx, (double)(j)/ly));
		}

	double sum=0.0;
	for(int i=0; i<lx; i++)
		for(int j=0; j<ly; j++)
		{
			if(i==0 && j==0)
				continue;
			GeometryVector k=(double)(i)*cc.GetReciprocalBasisVector(0)+(double)(j)*cc.GetReciprocalBasisVector(1);
			double s=StructureFactor(cc, k);
			sum+=(s-1.0)*(s-1.0);
		}

	std::cout<<"Order metric="<<sum<<'\n';
	std::cout<<"Number of ups="<<cc.NumParticle()<<'\n';
	SkComputation sk(std::cin, std::cout);
	sk.Compute([&](size_t i)->Configuration {return cc;}, 1);
	sk.Plot("MonaLisa_Small", "");

	return 0;
}
#include <boost/math/special_functions.hpp>
int PairStatisticsDebug()
{
	{
		{
			Configuration c = ReadPos("Penrose");
			SingleConfiguration sc(c);
			SkComputation com(std::cin, std::cout);
			com.Compute(sc, 1);
			com.Plot("Penrose", "");
			return 0;
		}
	}

	//for(int r=4; r<=32; r*=2)
	//{
	//	std::stringstream name;
	//	name<<"2D_0.4_"<<r<<"_WindowNumberDistribution";
	//	std::vector<std::vector<GeometryVector> > result;
	//	ReadGraceData(result, name.str());
	//	std::vector<GeometryVector> & data=result[0];
	//	double mean=0, mean2=0;
	//	for(auto iter=data.begin(); iter!=data.end(); ++iter)
	//	{
	//		mean+=iter->x[1]*iter->x[0];
	//		mean2+=iter->x[1]*iter->x[0]*iter->x[0];
	//	}
	//	double var=mean2-mean*mean;
	//	double coeff=1.0/std::sqrt(2*pi*var);
	//	double min=data.front().x[0], max=data.back().x[0];
	//	result.push_back(std::vector<GeometryVector>());
	//	for(double n=min; n<max; n+=0.003*(max-min))
	//	{
	//		result.back().push_back(GeometryVector(n, coeff*std::exp((-0.5)*(n-mean)*(n-mean)/var)));
	//	}
	//	name<<"_withGaussian";
	//	std::vector<std::string> legends;
	//	legends.push_back("Simulation");
	//	legends.push_back("Gaussian");
	//	PlotFunction_Grace(&result[0], 2, name.str(), "N", "p(N)", legends, ""); 
	//}

	//return 0;
	//int Np=10;//side length of 2D crystal
	//int Nc=10000;
	//std::cin>>Np>>Nc;

	//for(double disp=1.0; disp>0.05; disp-=0.1)
	//{
	//	auto GetConfigsFunc = [&](int i)->Configuration
	//	{
	//		RandomGenerator gen(12345+i);
	//		Configuration c=MultiplicateStructure(ReadPos("2D/Square"), Np);
	//		for(int i=0; i<c.NumParticle(); i++)
	//		{
	//			GeometryVector rel=c.GetRelativeCoordinates(i);
	//			rel.x[0]+=disp/Np*(gen.RandomDouble()-0.5);
	//			rel.x[1]+=disp/Np*(gen.RandomDouble()-0.5);
	//			c.MoveParticle(i, rel);
	//		}
	//		return c;
	//	};
	//	std::stringstream ss, ss2, ss3, ss4;
	//	ss<<2.5;
	//	g2Computation g2(ss, ss2);
	//	g2.Compute(GetConfigsFunc, Nc);
	//	ss4<<"10.0 20.0 0.1";
	//	SkComputation sk(ss4, ss2);
	//	sk.Compute(GetConfigsFunc, Nc);
	//	ss3<<"2D_PerturbedSqu_"<<Np<<"_"<<Nc<<"_"<<disp;
	//	g2.Plot(ss3.str(), "");
	//	sk.Plot(ss3.str(), "");
	//}
	//return 0;

	////Process results, combine, running average/median, shift S(k)
	//auto GetSkFunc = [] (int d, double chi) ->std::vector<GeometryVector>
	//{
	//	//S(k) analytical
	//	std::vector<GeometryVector> result;
	//	result.push_back(GeometryVector(0.0, 0.0));
	//	for(double k=0.0002; k<10; k+=0.0002)
	//	{
	//		double eta;

	//		if(d==1)
	//			eta=chi;
	//		else if(d==2)
	//			eta=0.639382560711962*chi;
	//		else if(d==3)
	//			eta=0.4*chi;
	//		double Sk;
	//		if(k<1)
	//			Sk=0.0;
	//		else if(k<2)
	//		{
	//			if(d==1)
	//				Sk=1.0+2*eta*(1-k*0.5);
	//			else if(d==2)
	//				Sk=1.0+4*eta*2/pi*(std::acos(k*0.5)-k*0.5*std::sqrt(1-k*k*0.25));
	//			else if(d==3)
	//				Sk=1.0+8*eta*(1-0.75*k+k*k*k/16.0);
	//		}
	//		else
	//			Sk=1.0;
	//		result.push_back(GeometryVector(k, Sk));
	//	}
	//	return result;
	//};
	//auto Getg2Func = [&] (int d, double chi) ->std::vector<GeometryVector>
	//{
	//	std::vector<GeometryVector> result;
	//	std::vector<GeometryVector> sk=GetSkFunc(d, chi);
	//	//g2(r) analytical
	//	for(double r=0.01; r<10; r+=0.01)
	//	{
	//		//use the 3rd column of sk to store the integrand
	//		for(auto iter=sk.begin(); iter!=sk.end() && iter->x[0]<2; iter++)
	//		{
	//			double k=iter->x[0];
	//			double f=iter->x[1]-1.0;
	//			if(d==1)
	//				iter->x[2]=f*std::cos(k*r)/pi;
	//			else if(d==2)
	//				iter->x[2]=f*k*boost::math::cyl_bessel_j(0.0, k*r)/2/pi;
	//			else if(d==3)
	//				iter->x[2]=f*k*std::sin(k*r)/2/pi/pi/r;
	//			iter->x[2]*=( (iter+1)->x[0]-k );
	//		}
	//		double g2=0.0;
	//		g2+=0.5*sk[0].x[2];
	//		for(auto iter=sk.begin()+1; iter!=sk.end() && iter!=sk.end()-1; iter++)
	//			g2+=iter->x[2];
	//		g2+=0.5*sk[sk.size()-1].x[2];
	//		g2/=HyperSphere_Volume(d, 1.0)/2/d/std::pow(2*pi, d)/chi;
	//		g2+=1.0;
	//		
	//		result.push_back(GeometryVector(r, g2));
	//	}	
	//	return result;
	//};
	//std::vector<size_t> InvChis;
	//InvChis.push_back(20);
	//InvChis.push_back(10);
	//InvChis.push_back(7);
	//InvChis.push_back(5);
	//InvChis.push_back(4);
	//std::vector< std::string > Names;
	//Names.push_back("PairCorrelation");
	//Names.push_back("StructureFactor");
	////Names.push_back("NearestNeighborDistance");
	//std::vector< std::string > xLabels;
	//xLabels.push_back("r");
	//xLabels.push_back("k");
	////xLabels.push_back("r");
	//std::vector< std::string > yLabels;
	//yLabels.push_back("g\\s2\\N(r)");
	//yLabels.push_back("S(k)");
	////yLabels.push_back("H\\sp\\N(r)");
	//for(auto iter=InvChis.begin(); iter!=InvChis.end(); iter++)
	//{
	//	for(int i=0; i<Names.size(); i++)
	//	{
	//		std::cout<<1.0/(*iter)<<Names[i]<<'\n';
	//		std::vector< std::string > legends;
	//		std::vector< std::vector<GeometryVector> > data(3, std::vector<GeometryVector>() );
	//		{
	//			std::stringstream ss;
	//			ss<<"C:/cygwin64/home/gezhang/MD_fixK_1D/315/"<<50*(*iter)+1<<"/2e-4/1D_2e-4_"<<1.0/(*iter)<<"_"<<Names[i];
	//			ReadFunction(data[0], ss.str(), 4);
	//		}
	//		{
	//			std::stringstream ss;
	//			ss<<"d=1,T\\sE\\N=2e-4,N\\sp\\N="<<50*(*iter);
	//			legends.push_back(ss.str());
	//		}
	//		{
	//			std::stringstream ss;
	//			ss<<"C:/cygwin64/home/gezhang/MD_fixK_2D/40/"<<27*(*iter)+1<<"/2e-6/2D_2e-6_"<<1.0/(*iter)<<"_"<<Names[i];
	//			ReadFunction(data[1], ss.str(), 4);
	//		}
	//		{
	//			std::stringstream ss;
	//			ss<<"d=2,T\\sE\\N=2e-6,N\\sp\\N="<<27*(*iter);
	//			legends.push_back(ss.str());
	//		}
	//		{
	//			std::stringstream ss;
	//			ss<<"C:/cygwin64/home/gezhang/MD_fixK_3D/20/"<<13*(*iter)+1<<"/1e-6/3D_1e-6_"<<1.0/(*iter)<<"_"<<Names[i];
	//			ReadFunction(data[2], ss.str(), 4);
	//		}
	//		{
	//			std::stringstream ss;
	//			ss<<"d=3,T\\sE\\N=1e-6,N\\sp\\N="<<13*(*iter);
	//			legends.push_back(ss.str());
	//		}
	//		for(int ii=0; ii<3; ii++)
	//		{
	//			std::vector<GeometryVector> & mydata = data[ii];
	//			if(i==0)
	//			{
	//				//running median for g2(r)
	//				std::vector<GeometryVector> data2;
	//				for(auto iter=mydata.begin()+2; iter!=mydata.end()-2; iter++)
	//				{
	//					std::vector<double> temp;
	//					temp.push_back( (iter-2)->x[1] );
	//					temp.push_back( (iter-1)->x[1] );
	//					temp.push_back( (iter)->x[1] );
	//					temp.push_back( (iter+1)->x[1] );
	//					temp.push_back( (iter+2)->x[1] );
	//					std::nth_element(temp.begin(), temp.begin()+2, temp.end());
	//					data2.push_back(GeometryVector(iter->x[0], temp[2]));
	//				}
	//				std::swap(data2, mydata);
	//			}
	//			if(i==1)
	//			{
	//				//shift the S(k) values so that peak is at 1
	//				auto iter=mydata.begin();
	//				std::vector<GeometryVector> data2;
	//				double shift=0.0;
	//				for(; iter!=mydata.end(); iter++)
	//				{
	//					if(iter->x[0]>1)
	//					{
	//						data2.push_back( GeometryVector(0.999999, 2.73503e-022) );
	//						shift=iter->x[0]-1;
	//						break;
	//					}
	//					else
	//					{
	//						data2.push_back( GeometryVector(iter->x[0], iter->x[1]) );
	//					}
	//				}
	//				//also do a running median
	//				//the running median is specially designed to not change peak value
	//				size_t MedianSpan=0;
	//				if(ii==1)//2D span
	//					MedianSpan=2;
	//				else if(ii==0)//1D span
	//					MedianSpan=4;
	//				for(; iter!=mydata.end(); iter++)
	//				{
	//					std::vector<double> temp;
	//					temp.push_back( iter->x[1] );
	//					for(int jj=1; jj<=MedianSpan; jj++)
	//					{
	//						if( iter<mydata.end()-jj && (iter-jj)->x[0]>1.0)
	//						{
	//							temp.push_back((iter+jj)->x[1]);
	//							temp.push_back((iter-jj)->x[1]);
	//						}
	//					}
	//					//try average instead
	//					double sum=0.0;
	//					for(auto iter=temp.begin(); iter!=temp.end(); iter++)
	//						sum+=*iter;
	//					data2.push_back( GeometryVector(iter->x[0]-shift, sum/temp.size()));

	//					//size_t mid=temp.size()/2;
	//					//std::nth_element(temp.begin(), temp.begin()+mid, temp.end());
	//					//data2.push_back( GeometryVector(iter->x[0]-shift, temp[mid]));
	//				}
	//				std::swap(data2, mydata);
	//			}
	//			if(i==2 && ii==0)
	//			{
	//				//running median for H_p(r) for 1D
	//				std::vector<GeometryVector> data2;
	//				for(auto iter=mydata.begin()+2; iter!=mydata.end()-2; iter++)
	//				{
	//					std::vector<double> temp;
	//					temp.push_back( (iter-2)->x[1] );
	//					temp.push_back( (iter-1)->x[1] );
	//					temp.push_back( (iter)->x[1] );
	//					temp.push_back( (iter+1)->x[1] );
	//					temp.push_back( (iter+2)->x[1] );
	//					std::nth_element(temp.begin(), temp.begin()+2, temp.end());
	//					data2.push_back(GeometryVector(iter->x[0], temp[2]));
	//				}
	//				std::swap(data2, mydata);
	//			}
	//		}

	//		if(i==0)
	//		{
	//			data.push_back(Getg2Func(1, 1.0/(*iter))); 
	//			legends.push_back("d=1, Analytical");
	//			data.push_back(Getg2Func(2, 1.0/(*iter))); 
	//			legends.push_back("d=2, Analytical");
	//			data.push_back(Getg2Func(3, 1.0/(*iter))); 
	//			legends.push_back("d=3, Analytical");
	//		}
	//		else if(i==1)
	//		{
	//			data.push_back(GetSkFunc(1, 1.0/(*iter))); 
	//			legends.push_back("d=1, Analytical");
	//			data.push_back(GetSkFunc(2, 1.0/(*iter))); 
	//			legends.push_back("d=2, Analytical");
	//			data.push_back(GetSkFunc(3, 1.0/(*iter))); 
	//			legends.push_back("d=3, Analytical");
	//		}
	//		std::stringstream GraceFilePrefix;
	//		GraceFilePrefix<<"1D_2D_3D_"<<1.0/(*iter)<<"_20000_"<<Names[i]<<"_Processed_withAnalytical";
	//		std::stringstream GraceTitle;
	//		GraceTitle<<"\\xc\\f{}="<<1.0/(*iter)<<",N\\sc\\N=20000";
	//		if(i==0)
	//			::PlotFunction_Grace(&data[0], data.size(), GraceFilePrefix.str(), xLabels[i], yLabels[i], legends, GraceTitle.str(), 0, 10, 5, 0, 1.5, 0.5);
	//		else if(i==1)
	//			::PlotFunction_Grace(&data[0], data.size(), GraceFilePrefix.str(), xLabels[i], yLabels[i], legends, GraceTitle.str(), 0, 4, 1, 0, 1.5, 0.5);
	//	}
	//}

	//return 0;
}
