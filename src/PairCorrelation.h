#ifndef PAIRCORRELATION_INCLUDED
#define PAIRCORRELATION_INCLUDED

#include "PeriodicCellList.h"
#include <vector>


class HistogramGenerator
{
public:
	struct bin
	{
		size_t Count;
		double Start;
		bin(size_t Count, double Start) : Count(Count), Start(Start){}
		bin() : Count(0), Start(0){}
	};
	std::vector<bin> bins;

private:
	void Iteration(double MinDist, double MaxDist, std::vector<double>::iterator begin, std::vector<double>::iterator end, double MoreData, double MinBinWidth, double TotalRange)
	{
		double count=static_cast<double>(end-begin);
		double yError = 1.0/std::sqrt(count*MoreData);//if treat these distances as a point in g_2, this is the estimated relative error in y direction
		//double Center = (MaxDist+MinDist)/2.0;
		double xError = (MaxDist-MinDist)/TotalRange/2.0;
		//if(yError>xError || count<3 || MaxDist==MinDist || MaxDist-MinDist<MinBinWidth)

		if(yError>xError || count<3 || MaxDist-MinDist<MinBinWidth)
		{
			//treat this chunk of distances as a point
			if(bins.empty())
			{
				//create a new bin, we also want to insert empty bins before the first non-empty bin
				size_t EmptyBinCount = 100;

				if(EmptyBinCount>0)
				{
					double EmptyBinWidth=0.2*TotalRange/EmptyBinCount;
					for(size_t i=0; i<EmptyBinCount; i++)
					{
						bin temp;
						temp.Count=0;
						temp.Start=MinDist-0.2*TotalRange+i*EmptyBinWidth;
						bins.push_back(temp);
					}
				}
				else if(MinDist>0)
				{
					//always have a bin at 0
					bin temp;
					temp.Count=0;
					temp.Start=0.0;
					bins.push_back(temp);
				}
				bin temp;
				temp.Count=end-begin;
				temp.Start=MinDist;
				bins.push_back(temp);
			}
			else if(MinDist==bins.back().Start /*|| count<5*/)
			{
				//merge this into previous bin because either:
				//the bin is identical to the previous bin, or
				//the count is too small, the bin cannot be precise.
				bins.back().Count+=end-begin;
			}
			else
			{
				//debug temp
				//if (MaxDist - MinDist>10000) std::cout << MaxDist << " \t" << MinDist << " \t" << count << '\n';
				//create a new bin
				bin temp;
				temp.Count=end-begin;
				temp.Start=MinDist;
				bins.push_back(temp);
			}

		}
		else
		{
			//divide this chunk
			std::vector<double>::iterator mid=begin+(end-begin)/2;
			std::nth_element(begin, mid, end);
			Iteration(MinDist, *mid, begin, mid, MoreData, MinBinWidth, TotalRange);
			Iteration(*mid, MaxDist, mid, end, MoreData, MinBinWidth, TotalRange);
		}
	}
public:
	//count all data, generate bins using adaptive method, set the Count of each bin to their occurence in data
	//the vector data is changed upon return
	//MoreData=x indicated that x time more data are expedted to come
	//ResolutionPreference : >1 to get better x resolution, <1 to get better y resolution
	void GenerateBins(std::vector<double> & data, double MoreData, double ResolutionPreference, double MinBinWidth=0)
	{
		if(data.empty())
		{
			std::cerr<<"Error in HistogramGenerator::GenerateBins : no data!\n";
			return;
		}
		//std::nth_element(data.begin(), data.begin(), data.end());
		//std::nth_element(data.begin()+1, data.end()-1, data.end());

		//debug temp
		//for(auto iter=data.begin(); iter!=data.end(); iter++)
		//	std::cout<<*iter<<" \t";

		double Max=*std::max_element(data.begin(), data.end());
		double Min=*std::min_element(data.begin(), data.end());
		Iteration(Min, Max, data.begin(), data.end(), MoreData*ResolutionPreference, MinBinWidth, Max-Min); 

		//The bins generated by the previous iteration process is often too small. Merge them here.
		std::vector<bin> newBins;
		for(auto iter=this->bins.begin();;)
		{
			if(iter==bins.end())
				break;
			else if(iter==bins.end()-1)
			{
				newBins.push_back(*iter);
				break;
			}
			else
			{
				bin temp;
				temp.Count=iter->Count+(iter+1)->Count;
				temp.Start=iter->Start;
				newBins.push_back(temp);
				iter+=2;
			}
		}
		double dist = 0.2*(Max - Min) / 50.0;
		for(int i=0; i<50; i++)
		{
			bin temp;
			temp.Start=Max+i*dist;
			temp.Count=0;
			newBins.push_back(temp);
		}
		std::swap(newBins, this->bins);
	}

	std::vector<bin>::iterator findBin(const double & data)
	{
		//if user call Report() before calling GenerateBins(), assertion will fail.
		assert(this->bins.empty() == false);

		if (data<bins[0].Start)
		{
			std::cerr << "Warning in HistogramGenerator::Report : Data is out of range!\n";
			return this->bins.end();
		}
		bin temp;
		temp.Start = data;
		std::vector<bin>::iterator loc = std::upper_bound(bins.begin(), bins.end(), temp, [](const bin & left, const bin & right)->bool{return left.Start<right.Start; });
		assert(loc != bins.begin());
		loc--;// decrease it by one because std::upper_bound returns the first iterator which is GREATER. However, our bin::Start is the start location of the bin
		return loc;
	}

	//report a new data, increase the corresponding bin count by 1
	//call it after calling GenerateBins
	//This member function is thread safe
	void Report(const double & data)
	{
		std::vector<bin>::iterator loc = findBin(data);

		if (loc != this->bins.end())
		{
#pragma omp atomic
			loc->Count++;
		}
	}
};

//clear Result, then fill it with the pair correlation data calculated from Config
//Result is filled with 4-dimensional GeometryVectors, the elements are:
//(r, g_2(r), \delta r, \delta g_2(r) )
//gets SampleDistanceSize number of sample pair distances, use it to generate bins, then count all pair distances
//ResolutionPreference : >1 to get better r resolution, <1 to get better g_2 resolution
//specify wantedSpecies to calculate g2(r) between two desired species
void IsotropicTwoPairCorrelation(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, double MaxDistance, std::vector<GeometryVector> & Result, size_t SampleDistanceSize = 5000000, double ResolutionPreference = 1.0, AtomInfo wantedSpeciesX = AtomInfo(""), AtomInfo wantedSpeciesY = AtomInfo(""));

//this version allow user to specify the bins through $gen$
void IsotropicTwoPairCorrelation(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, double MaxDistance, std::vector<GeometryVector> & Result, HistogramGenerator & HGen);

//clear Result, then fill it with the pair correlation data calculated from Config
//Result is filled with 3-dimensional GeometryVectors, the elements are:
//(r, theta, g_2(r) )
//r bins are adaptively generated
//gets SampleDistanceSize number of sample pair distances, use it to generate bins, then count all pair distances
//ResolutionPreference : >1 to get better r resolution, <1 to get better g_2 resolution
//theta bins are fixed. there are NumDirectionalBins of them. 
//if pError is not nullptr, it is filled with 3-dimensional GeometryVectors, the elements are:
//(delta r, delta theta = pi/(2*NumDirectionalBins), delta g_2(r) )
void TwoPairCorrelation_2DAnisotropic(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, double MaxDistance, std::vector<std::vector<GeometryVector> > & Result, size_t NumDirectionalBins, std::vector<std::vector<GeometryVector> > * pError=nullptr, size_t SampleDistanceSize=2000000, double ResolutionPreference=1.0);


//Probability density function of the nearest neighbor distance
//clear Result, then fill it with the PDF calculated from Config
//Result is filled with 4-dimensional GeometryVectors, the elements are:
//(r, p(r), \delta r, \delta g_2(r) )
//gets SampleDistanceSize number of sample pair distances, use it to generate bins, then count all pair distances
//ResolutionPreference : >1 to get better r resolution, <1 to get better g_2 resolution
void NearestNeighborDistrubution(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, std::vector<GeometryVector> & Result, size_t SampleDistanceSize=500000, double ResolutionPreference=1.0);

//calculate Hv
//Each configuration will be sampled OverSampling*NumParticle() times
void HvDistrubution(std::function<const Configuration(size_t i)> GetConfigsFunction, size_t NumConfigs, std::vector<GeometryVector> & Result, size_t SampleDistanceSize=500000, double ResolutionPreference=1.0, double OverSampling=1.0);


//return the minimum pair distance in the configuration
//if pi and pj are not nullptr, *pi and *pj will be set to the particles that are closest to each other
double MinDistance(const Configuration & a, size_t * pi=nullptr, size_t * pj=nullptr);


double MeanNearestNeighborDistance(const Configuration & a);


//convert histogram to probability density function or cumulative distribution function
//return total count the HistogramGenerator has
size_t HistogramToPDF(const HistogramGenerator & HGen, std::vector<GeometryVector> & result);
size_t HistogramToCDF(const HistogramGenerator & HGen, std::vector<GeometryVector> & result);


#endif